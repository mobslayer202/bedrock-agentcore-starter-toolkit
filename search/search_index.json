{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Amazon Bedrock AgentCore","text":"<p>Amazon Bedrock AgentCore is a comprehensive platform for deploying and operating highly effective AI agents securely at scale. The platform includes a Python SDK and Starter Toolkit that work together to help you build, deploy, and manage agent applications.</p> <p> </p> Python SDK Starter Toolkit Samples <p>Preview Status</p> <p>Amazon Bedrock AgentCore is currently in preview release. APIs may change as we refine the platform.</p>"},{"location":"index.html#from-local-development-to-bedrock-agentcore","title":"\ud83d\ude80 From Local Development to Bedrock AgentCore","text":"<pre><code># Your existing agent (any framework)\nfrom strands import Agent\n# or LangGraph, CrewAI, Autogen, custom logic - doesn't matter\n\ndef my_local_agent(query):\n    # Your carefully crafted agent logic\n    return agent.process(query)\n\n# Deploy to Bedrock AgentCore\nfrom bedrock_agentcore import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef production_agent(request):\n    return my_local_agent(request['query'])  # Same logic, enterprise platform\n\nproduction_agent.run()  # Ready to run on Bedrock AgentCore\n</code></pre> <p>What you get with Bedrock AgentCore:</p> <ul> <li>\u2705 Keep your agent logic - Works with Strands, LangGraph, CrewAI, Autogen, custom frameworks.</li> <li>\u2705 Zero infrastructure management - No servers, containers, or scaling concerns.</li> <li>\u2705 Enterprise-grade platform - Built-in auth, memory, observability, security.</li> <li>\u2705 Production-ready deployment - Reliable, scalable, compliant hosting.</li> </ul> <p>Your function is now a production-ready API server with health monitoring, streaming support, and AWS integration.</p>"},{"location":"index.html#platform-components","title":"Platform Components","text":""},{"location":"index.html#bedrock-agentcore-sdk","title":"\ud83d\udd27 Bedrock AgentCore SDK","text":"<p>The SDK provides Python primitives for agent development with built-in support for:</p> <ul> <li>Runtime: Lightweight wrapper to convert functions into API servers</li> <li>Memory: Persistent storage for conversation history and agent context</li> <li>Tools: Built-in clients for code interpretation and browser automation</li> <li>Identity: Secure authentication and access management</li> </ul>"},{"location":"index.html#bedrock-agentcore-starter-toolkit","title":"\ud83d\ude80 Bedrock AgentCore Starter Toolkit","text":"<p>The Toolkit provides CLI tools and higher-level abstractions for:</p> <ul> <li>Deployment: Containerize and deploy agents to AWS infrastructure</li> <li>Gateway Integration: Transform existing APIs into agent tools</li> <li>Configuration Management: Manage environment and deployment settings</li> <li>Observability: Monitor agents in production environments</li> </ul>"},{"location":"index.html#platform-services","title":"Platform Services","text":"<p>Amazon Bedrock AgentCore provides enterprise-grade services for AI agent development:</p> <ul> <li>\ud83d\ude80 AgentCore Runtime - Serverless deployment and scaling for dynamic AI agents</li> <li>\ud83e\udde0 AgentCore Memory - Persistent knowledge with event and semantic memory</li> <li>\ud83d\udcbb AgentCore Code Interpreter - Secure code execution in isolated sandboxes</li> <li>\ud83c\udf10 AgentCore Browser - Fast, secure cloud-based browser for web interaction</li> <li>\ud83d\udd17 AgentCore Gateway - Transform existing APIs into agent tools</li> <li>\ud83d\udcca AgentCore Observability - Real-time monitoring and tracing</li> <li>\ud83d\udd10 AgentCore Identity - Secure authentication and access management</li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li> <p> SDK Quickstart</p> <p>Get started with the core SDK for agent development</p> <p> Start coding</p> </li> <li> <p> Toolkit Guide</p> <p>Learn to deploy and manage agents in production</p> <p> Deploy agents</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation for developers</p> <p> Explore APIs</p> </li> </ul>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Zero Code Changes: Your existing functions remain untouched</li> <li>Production Ready: Automatic HTTP endpoints with health monitoring</li> <li>Streaming Support: Native support for generators and async generators</li> <li>Framework Agnostic: Works with any AI framework (Strands, LangGraph, LangChain, custom)</li> <li>AWS Optimized: Ready for deployment to AWS infrastructure</li> <li>Enterprise Security: Built-in identity, isolation, and access controls</li> </ul>"},{"location":"api-reference/cli.html","title":"CLI","text":"<p>Command-line interface for BedrockAgentCore Starter Toolkit.</p> <p>The <code>agentcore</code> CLI provides commands for configuring, launching, managing agents, and working with gateways.</p>"},{"location":"api-reference/cli.html#runtime-commands","title":"Runtime Commands","text":""},{"location":"api-reference/cli.html#configure","title":"Configure","text":"<p>Configure agents and runtime environments.</p> <pre><code>agentcore configure [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--entrypoint, -e TEXT</code>: Python file of agent</p> </li> <li> <p><code>--name, -n TEXT</code>: Agent name (defaults to Python file name)</p> </li> <li> <p><code>--execution-role, -er TEXT</code>: IAM execution role ARN</p> </li> <li> <p><code>--ecr, -ecr TEXT</code>: ECR repository name (use \"auto\" for automatic creation)</p> </li> <li> <p><code>--container-runtime, -ctr TEXT</code>: Container runtime</p> </li> <li> <p><code>--requirements-file, -rf TEXT</code>: Path to requirements file of agent</p> </li> <li> <p><code>--disable-otel, -do</code>: Disable OpenTelemetry</p> </li> <li> <p><code>--authorizer-config, -ac TEXT</code>: OAuth authorizer configuration as JSON string</p> </li> <li> <p><code>--verbose, -v</code>: Enable verbose output</p> </li> <li> <p><code>--region, -r TEXT</code>: AWS region</p> </li> <li> <p><code>--protocol, -p TEXT</code>: Agent server protocol (HTTP or MCP)</p> </li> </ul> <p>Subcommands:</p> <ul> <li> <p><code>list</code>: List configured agents</p> </li> <li> <p><code>set-default</code>: Set default agent</p> </li> </ul>"},{"location":"api-reference/cli.html#launch","title":"Launch","text":"<p>Deploy agents to AWS or run locally.</p> <pre><code>agentcore launch [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--local, -l</code>: Run locally</p> </li> <li> <p><code>--push-ecr, -p</code>: Build and push to ECR only (no deployment)</p> </li> <li> <p><code>--env, -env TEXT</code>: Environment variables for agent (format: KEY=VALUE)</p> </li> </ul>"},{"location":"api-reference/cli.html#invoke","title":"Invoke","text":"<p>Invoke deployed agents.</p> <pre><code>agentcore invoke [PAYLOAD] [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>PAYLOAD</code>: JSON payload to send</li> </ul> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--session-id, -s TEXT</code>: Session ID</p> </li> <li> <p><code>--bearer-token, -bt TEXT</code>: Bearer token for OAuth authentication</p> </li> <li> <p><code>--local, -l</code>: Send request to a running local container</p> </li> <li> <p><code>--user-id, -u TEXT</code>: User ID for authorization flows</p> </li> </ul>"},{"location":"api-reference/cli.html#status","title":"Status","text":"<p>Get Bedrock AgentCore status including config and runtime details.</p> <pre><code>agentcore status [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--verbose, -v</code>: Verbose JSON output of config, agent, and endpoint status</p> </li> </ul>"},{"location":"api-reference/cli.html#gateway-commands","title":"Gateway Commands","text":"<p>Access gateway subcommands:</p> <pre><code>agentcore gateway [COMMAND]\n</code></pre>"},{"location":"api-reference/cli.html#create-mcp-gateway","title":"Create MCP Gateway","text":"<pre><code>agentcore gateway create-mcp-gateway [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the gateway (defaults to TestGateway)</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN to use (creates one if none provided)</p> </li> <li> <p><code>--authorizer-config TEXT</code>: Serialized authorizer config</p> </li> <li> <p><code>--enable-semantic-search, -sem</code>: Whether to enable search tool (defaults to True)</p> </li> </ul>"},{"location":"api-reference/cli.html#create-mcp-gateway-target","title":"Create MCP Gateway Target","text":"<pre><code>agentcore gateway create-mcp-gateway-target [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--gateway-arn TEXT</code>: ARN of the created gateway</p> </li> <li> <p><code>--gateway-url TEXT</code>: URL of the created gateway</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN of the created gateway</p> </li> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the target (defaults to TestGatewayTarget)</p> </li> <li> <p><code>--target-type TEXT</code>: Type of target (lambda, openApiSchema, smithyModel)</p> </li> <li> <p><code>--target-payload TEXT</code>: Specification of the target (required for openApiSchema)</p> </li> <li> <p><code>--credentials TEXT</code>: Credentials for calling this target (API key or OAuth2)</p> </li> </ul>"},{"location":"api-reference/cli.html#example-usage","title":"Example Usage","text":""},{"location":"api-reference/cli.html#configure-an-agent","title":"Configure an Agent","text":"<pre><code># Basic configuration\nagentcore configure --entrypoint agent_example.pt\n\n# Configure with execution role\nagentcore configure --entrypoint agent_example.py --execution-role arn:aws:iam::123456789012:role/MyRole\n\n# List configured agents\nagentcore configure list\n\n# Set default agent\nagentcore configure set-default my_agent\n</code></pre>"},{"location":"api-reference/cli.html#deploy-and-run-agents","title":"Deploy and Run Agents","text":"<pre><code># Deploy to AWS\nagentcore launch\n\n# Run locally\nagentcore launch --local\n\n# Launch with environment variables\nagentcore launch --env API_KEY=abc123 --env DEBUG=true\n</code></pre>"},{"location":"api-reference/cli.html#invoke-agents","title":"Invoke Agents","text":"<pre><code># Basic invocation\nagentcore invoke '{\"prompt\": \"Hello world!\"}'\n\n# Invoke with session ID\nagentcore invoke '{\"prompt\": \"Continue our conversation\"}' --session-id abc123\n\n# Invoke with OAuth authentication\nagentcore invoke '{\"prompt\": \"Secure request\"}' --bearer-token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n# Invoke local agent\nagentcore invoke '{\"prompt\": \"Test locally\"}' --local\n</code></pre>"},{"location":"api-reference/cli.html#check-status","title":"Check Status","text":"<pre><code># Get status of default agent\nagentcore status\n\n# Get status of specific agent\nagentcore status --agent my-agent\n</code></pre>"},{"location":"api-reference/cli.html#gateway-operations","title":"Gateway Operations","text":"<pre><code># Create MCP Gateway\nagentcore gateway create-mcp-gateway --name MyGateway\n\n# Create MCP Gateway Target\nagentcore gateway create-mcp-gateway-target \\\n  --gateway-arn arn:aws:bedrock-agentcore:us-west-2:123456789012:gateway/abcdef \\\n  --gateway-url https://gateway-url.us-west-2.amazonaws.com \\\n  --role-arn arn:aws:iam::123456789012:role/GatewayRole\n</code></pre>"},{"location":"api-reference/identity.html","title":"Identity","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/identity.html#service-client","title":"Service client","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity","title":"<code>bedrock_agentcore.services.identity</code>","text":"<p>The main high-level client for the Bedrock AgentCore Identity service.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient","title":"<code>IdentityClient</code>","text":"<p>A high-level client for Bedrock AgentCore Identity.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class IdentityClient:\n    \"\"\"A high-level client for Bedrock AgentCore Identity.\"\"\"\n\n    def __init__(self, region: str):\n        \"\"\"Initialize the identity client with the specified region.\"\"\"\n        self.region = region\n        self.cp_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n        )\n        self.identity_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.dp_client = boto3.client(\n            \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n\n    def create_oauth2_credential_provider(self, req):\n        \"\"\"Create an OAuth2 credential provider.\"\"\"\n        self.logger.info(\"Creating OAuth2 credential provider...\")\n        return self.cp_client.create_oauth2_credential_provider(**req)\n\n    def create_api_key_credential_provider(self, req):\n        \"\"\"Create an API key credential provider.\"\"\"\n        self.logger.info(\"Creating API key credential provider...\")\n        return self.cp_client.create_api_key_credential_provider(**req)\n\n    def get_workload_access_token(\n        self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n    ) -&gt; Dict:\n        \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n        if user_token:\n            if user_id is not None:\n                self.logger.warning(\"Both user token and user id are supplied, using user token\")\n            self.logger.info(\"Getting workload access token for JWT...\")\n            resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n        elif user_id:\n            self.logger.info(\"Getting workload access token for user id...\")\n            resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n        else:\n            self.logger.info(\"Getting workload access token...\")\n            resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n        self.logger.info(\"Successfully retrieved workload access token\")\n        return resp\n\n    def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n        \"\"\"Create workload identity with optional name.\"\"\"\n        self.logger.info(\"Creating workload identity...\")\n        if not name:\n            name = f\"workload-{uuid.uuid4().hex[:8]}\"\n        return self.identity_client.create_workload_identity(name=name)\n\n    async def get_token(\n        self,\n        *,\n        provider_name: str,\n        scopes: Optional[List[str]] = None,\n        agent_identity_token: str,\n        on_auth_url: Optional[Callable[[str], Any]] = None,\n        auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n        callback_url: Optional[str] = None,\n        force_authentication: bool = False,\n        token_poller: Optional[TokenPoller] = None,\n    ) -&gt; str:\n        \"\"\"Get an OAuth2 access token for the specified provider.\n\n        Args:\n            provider_name: The credential provider name\n            scopes: Optional list of OAuth2 scopes to request\n            agent_identity_token: Agent identity token for authentication\n            on_auth_url: Callback for handling authorization URLs\n            auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n            callback_url: OAuth2 callback URL (must be pre-registered)\n            force_authentication: Force re-authentication even if token exists in the token vault\n            token_poller: Custom token poller implementation\n\n        Returns:\n            The access token string\n\n        Raises:\n            RequiresUserConsentException: When user consent is needed\n            Various other exceptions for error conditions\n        \"\"\"\n        self.logger.info(\"Getting OAuth2 token...\")\n\n        # Build parameters\n        req = {\n            \"resourceCredentialProviderName\": provider_name,\n            \"scopes\": scopes,\n            \"oauth2Flow\": auth_flow,\n            \"workloadIdentityToken\": agent_identity_token,\n        }\n\n        # Add optional parameters\n        if callback_url:\n            req[\"callBackUrl\"] = callback_url\n        if force_authentication:\n            req[\"forceAuthentication\"] = force_authentication\n\n        response = self.dp_client.get_resource_oauth2_token(**req)\n\n        # If we got a token directly, return it\n        if \"accessToken\" in response:\n            return response[\"accessToken\"]\n\n        # If we got an authorization URL, handle the OAuth flow\n        if \"authorizationUrl\" in response:\n            auth_url = response[\"authorizationUrl\"]\n            # Notify about the auth URL if callback provided\n            if on_auth_url:\n                if asyncio.iscoroutinefunction(on_auth_url):\n                    await on_auth_url(auth_url)\n                else:\n                    on_auth_url(auth_url)\n\n            # only the initial request should have force authentication\n            if force_authentication:\n                req[\"forceAuthentication\"] = False\n\n            # Poll for the token\n            active_poller = token_poller or _DefaultApiTokenPoller(\n                auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n            )\n            return await active_poller.poll_for_token()\n\n        raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n\n    async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n        \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n        self.logger.info(\"Getting API key...\")\n        req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n        return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize the identity client with the specified region.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def __init__(self, region: str):\n    \"\"\"Initialize the identity client with the specified region.\"\"\"\n    self.region = region\n    self.cp_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n    )\n    self.identity_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.dp_client = boto3.client(\n        \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_api_key_credential_provider","title":"<code>create_api_key_credential_provider(req)</code>","text":"<p>Create an API key credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_api_key_credential_provider(self, req):\n    \"\"\"Create an API key credential provider.\"\"\"\n    self.logger.info(\"Creating API key credential provider...\")\n    return self.cp_client.create_api_key_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_oauth2_credential_provider","title":"<code>create_oauth2_credential_provider(req)</code>","text":"<p>Create an OAuth2 credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_oauth2_credential_provider(self, req):\n    \"\"\"Create an OAuth2 credential provider.\"\"\"\n    self.logger.info(\"Creating OAuth2 credential provider...\")\n    return self.cp_client.create_oauth2_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_workload_identity","title":"<code>create_workload_identity(name=None)</code>","text":"<p>Create workload identity with optional name.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n    \"\"\"Create workload identity with optional name.\"\"\"\n    self.logger.info(\"Creating workload identity...\")\n    if not name:\n        name = f\"workload-{uuid.uuid4().hex[:8]}\"\n    return self.identity_client.create_workload_identity(name=name)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_api_key","title":"<code>get_api_key(*, provider_name, agent_identity_token)</code>  <code>async</code>","text":"<p>Programmatically retrieves an API key from the Identity service.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n    \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n    self.logger.info(\"Getting API key...\")\n    req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n    return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_token","title":"<code>get_token(*, provider_name, scopes=None, agent_identity_token, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>  <code>async</code>","text":"<p>Get an OAuth2 access token for the specified provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>scopes</code> <code>Optional[List[str]]</code> <p>Optional list of OAuth2 scopes to request</p> <code>None</code> <code>agent_identity_token</code> <code>str</code> <p>Agent identity token for authentication</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL (must be pre-registered)</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication even if token exists in the token vault</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The access token string</p> <p>Raises:</p> Type Description <code>RequiresUserConsentException</code> <p>When user consent is needed</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_token(\n    self,\n    *,\n    provider_name: str,\n    scopes: Optional[List[str]] = None,\n    agent_identity_token: str,\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; str:\n    \"\"\"Get an OAuth2 access token for the specified provider.\n\n    Args:\n        provider_name: The credential provider name\n        scopes: Optional list of OAuth2 scopes to request\n        agent_identity_token: Agent identity token for authentication\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL (must be pre-registered)\n        force_authentication: Force re-authentication even if token exists in the token vault\n        token_poller: Custom token poller implementation\n\n    Returns:\n        The access token string\n\n    Raises:\n        RequiresUserConsentException: When user consent is needed\n        Various other exceptions for error conditions\n    \"\"\"\n    self.logger.info(\"Getting OAuth2 token...\")\n\n    # Build parameters\n    req = {\n        \"resourceCredentialProviderName\": provider_name,\n        \"scopes\": scopes,\n        \"oauth2Flow\": auth_flow,\n        \"workloadIdentityToken\": agent_identity_token,\n    }\n\n    # Add optional parameters\n    if callback_url:\n        req[\"callBackUrl\"] = callback_url\n    if force_authentication:\n        req[\"forceAuthentication\"] = force_authentication\n\n    response = self.dp_client.get_resource_oauth2_token(**req)\n\n    # If we got a token directly, return it\n    if \"accessToken\" in response:\n        return response[\"accessToken\"]\n\n    # If we got an authorization URL, handle the OAuth flow\n    if \"authorizationUrl\" in response:\n        auth_url = response[\"authorizationUrl\"]\n        # Notify about the auth URL if callback provided\n        if on_auth_url:\n            if asyncio.iscoroutinefunction(on_auth_url):\n                await on_auth_url(auth_url)\n            else:\n                on_auth_url(auth_url)\n\n        # only the initial request should have force authentication\n        if force_authentication:\n            req[\"forceAuthentication\"] = False\n\n        # Poll for the token\n        active_poller = token_poller or _DefaultApiTokenPoller(\n            auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n        )\n        return await active_poller.poll_for_token()\n\n    raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_workload_access_token","title":"<code>get_workload_access_token(workload_name, user_token=None, user_id=None)</code>","text":"<p>Get a workload access token using workload name and optionally user token.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def get_workload_access_token(\n    self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n) -&gt; Dict:\n    \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n    if user_token:\n        if user_id is not None:\n            self.logger.warning(\"Both user token and user id are supplied, using user token\")\n        self.logger.info(\"Getting workload access token for JWT...\")\n        resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n    elif user_id:\n        self.logger.info(\"Getting workload access token for user id...\")\n        resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n    else:\n        self.logger.info(\"Getting workload access token...\")\n        resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n    self.logger.info(\"Successfully retrieved workload access token\")\n    return resp\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller","title":"<code>TokenPoller</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for token polling implementations.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class TokenPoller(ABC):\n    \"\"\"Abstract base class for token polling implementations.\"\"\"\n\n    @abstractmethod\n    async def poll_for_token(self) -&gt; str:\n        \"\"\"Poll for a token and return it when available.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller.poll_for_token","title":"<code>poll_for_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Poll for a token and return it when available.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>@abstractmethod\nasync def poll_for_token(self) -&gt; str:\n    \"\"\"Poll for a token and return it when available.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#decorators","title":"Decorators","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.identity","title":"<code>bedrock_agentcore.identity</code>","text":"<p>Bedrock AgentCore SDK identity package.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_access_token","title":"<code>requires_access_token(*, provider_name, into='access_token', scopes, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>","text":"<p>Decorator that fetches an OAuth2 access token before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the token into</p> <code>'access_token'</code> <code>scopes</code> <code>List[str]</code> <p>OAuth2 scopes to request</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_access_token(\n    *,\n    provider_name: str,\n    into: str = \"access_token\",\n    scopes: List[str],\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; Callable:\n    \"\"\"Decorator that fetches an OAuth2 access token before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the token into\n        scopes: OAuth2 scopes to request\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL\n        force_authentication: Force re-authentication\n        token_poller: Custom token poller implementation\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_token() -&gt; str:\n            \"\"\"Common token fetching logic.\"\"\"\n            return await client.get_token(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n                scopes=scopes,\n                on_auth_url=on_auth_url,\n                auth_flow=auth_flow,\n                callback_url=callback_url,\n                force_authentication=force_authentication,\n                token_poller=token_poller,\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            token = await _get_token()\n            kwargs_func[into] = token\n            return await func(*args, **kwargs_func)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_token())\n                    token = future.result()\n            else:\n                # for sync env, eg. local dev\n                token = asyncio.run(_get_token())\n\n            kwargs_func[into] = token\n            return func(*args, **kwargs_func)\n\n        # Return appropriate wrapper based on function type\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_api_key","title":"<code>requires_api_key(*, provider_name, into='api_key')</code>","text":"<p>Decorator that fetches an API key before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the API key into</p> <code>'api_key'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_api_key(*, provider_name: str, into: str = \"api_key\") -&gt; Callable:\n    \"\"\"Decorator that fetches an API key before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the API key into\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_api_key():\n            return await client.get_api_key(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            api_key = await _get_api_key()\n            kwargs[into] = api_key\n            return await func(*args, **kwargs)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_api_key())\n                    api_key = future.result()\n            else:\n                # for sync env, eg. local dev\n                api_key = asyncio.run(_get_api_key())\n\n            kwargs[into] = api_key\n            return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/memory.html","title":"Memory","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory","title":"<code>bedrock_agentcore.memory</code>","text":"<p>Bedrock AgentCore Memory module for agent memory management capabilities.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient","title":"<code>MemoryClient</code>","text":"<p>High-level Bedrock AgentCore Memory client with essential operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>class MemoryClient:\n    \"\"\"High-level Bedrock AgentCore Memory client with essential operations.\"\"\"\n\n    def __init__(self, region_name: Optional[str] = None):\n        \"\"\"Initialize the Memory client.\"\"\"\n        self.region_name = boto3.Session().region_name or region_name or \"us-west-2\"\n\n        self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n        self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n        logger.info(\n            \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n            self.gmcp_client.meta.region_name,\n            self.gmdp_client.meta.region_name,\n        )\n\n    def create_memory(\n        self,\n        name: str,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory with simplified configuration.\"\"\"\n        if strategies is None:\n            strategies = []\n\n        try:\n            processed_strategies = self._add_default_namespaces(strategies)\n\n            params = {\n                \"name\": name,\n                \"eventExpiryDuration\": event_expiry_days,\n                \"memoryStrategies\": processed_strategies,  # Using old field name for input\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if description is not None:\n                params[\"description\"] = description\n\n            if memory_execution_role_arn is not None:\n                params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n            response = self.gmcp_client.create_memory(**params)\n\n            memory = response[\"memory\"]\n            # Normalize response to handle new field names\n            memory = self._normalize_memory_response(memory)\n\n            logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def create_memory_and_wait(\n        self,\n        name: str,\n        strategies: List[Dict[str, Any]],\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory and wait for it to become ACTIVE.\n\n        This method creates a memory and polls until it reaches ACTIVE status,\n        providing a convenient way to ensure the memory is ready for use.\n\n        Args:\n            name: Name for the memory resource\n            strategies: List of strategy configurations\n            description: Optional description\n            event_expiry_days: How long to retain events (default: 90 days)\n            memory_execution_role_arn: IAM role ARN for memory execution\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between status checks (default: 10)\n\n        Returns:\n            Created memory object in ACTIVE status\n\n        Raises:\n            TimeoutError: If memory doesn't become ACTIVE within max_wait\n            RuntimeError: If memory creation fails\n        \"\"\"\n        # Create the memory\n        memory = self.create_memory(\n            name=name,\n            strategies=strategies,\n            description=description,\n            event_expiry_days=event_expiry_days,\n            memory_execution_role_arn=memory_execution_role_arn,\n        )\n\n        memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n        if memory_id is None:\n            memory_id = \"\"\n        logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                    # Get fresh memory details\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    # Get failure reason if available\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n\n    def retrieve_memories(\n        self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Retrieve relevant memories from a namespace.\n\n        Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n        exact namespace path with all variables resolved.\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace path (no wildcards)\n            query: Search query\n            actor_id: Optional actor ID (deprecated, use namespace)\n            top_k: Number of results to return\n\n        Returns:\n            List of memory records\n\n        Example:\n            # Correct - exact namespace\n            memories = client.retrieve_memories(\n                memory_id=\"mem-123\",\n                namespace=\"support/facts/session-456\",\n                query=\"customer preferences\"\n            )\n\n            # Incorrect - wildcards not supported\n            # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return []\n\n        try:\n            # Let service handle all namespace validation\n            response = self.gmdp_client.retrieve_memory_records(\n                memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n            )\n\n            memories = response.get(\"memoryRecordSummaries\", [])\n            logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n            return memories\n\n        except ClientError as e:\n            error_code = e.response[\"Error\"][\"Code\"]\n            error_msg = e.response[\"Error\"][\"Message\"]\n\n            if error_code == \"ResourceNotFoundException\":\n                logger.warning(\n                    \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                    memory_id,\n                    namespace,\n                )\n            elif error_code == \"ValidationException\":\n                logger.warning(\"Invalid search parameters: %s\", error_msg)\n            elif error_code == \"ServiceException\":\n                logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n            else:\n                logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n            return []\n\n    def create_event(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Save an event of an agent interaction or conversation with a user.\n\n        This is the basis of short-term memory. If you configured your Memory resource\n        to have MemoryStrategies, then events that are saved in short-term memory via\n        create_event will be used to extract long-term memory records.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (could be id of your user or an agent)\n            session_id: Session identifier (meant to logically group a series of events)\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n                   A branch is used when you want to have a different history of events.\n\n        Returns:\n            Created event\n\n        Example:\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"Today is sunny\", \"ASSISTANT\")\n                ]\n            )\n            root_event_id = event.get(\"eventId\")\n            print(event)\n\n            # Continue the conversation\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"How about the weather tomorrow\", \"USER\"),\n                    (\"Tomorrow is cold!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n\n            # branch the conversation so that the previous message is not part of the history\n            # (suppose you did not mean to ask about the weather tomorrow and want to undo\n            # that, and replace with a new message)\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n                messages=[\n                    (\"How about the weather a year from now\", \"USER\"),\n                    (\"I can't predict that far into the future!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            payload = []\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def save_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use create_event() instead.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: Optional timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n        Returns:\n            Created event\n\n        Example:\n            # Save multi-turn conversation\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"And tomorrow?\", \"USER\"),\n                    (\"Checking weather...\", \"TOOL\"),\n                    (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n                ]\n            )\n\n            # Continue existing branch (only name required)\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[(\"Continue conversation\", \"USER\")],\n                branch={\"name\": \"existing-branch\"}\n            )\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            # Build payload\n            payload = []\n\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                # Validate role\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def save_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"save_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use save_conversation() for flexible message handling.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n        return self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=messages,\n            event_timestamp=event_timestamp,\n        )\n\n    def process_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n    ) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n        \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"process_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        retrieved_memories = []\n\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n\n        event = self.save_turn(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            user_input=user_input,\n            agent_response=agent_response,\n            event_timestamp=event_timestamp,\n        )\n\n        return retrieved_memories, event\n\n    def process_turn_with_llm(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n        r\"\"\"Complete conversation turn with LLM callback integration.\n\n        This method combines memory retrieval, LLM invocation, and response storage\n        in a single call using a callback pattern.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (e.g., \"user-123\")\n            session_id: Session identifier\n            user_input: The user's message\n            llm_callback: Function that takes (user_input, memories) and returns agent_response\n                         The callback receives the user input and retrieved memories,\n                         and should return the agent's response string\n            retrieval_namespace: Namespace to search for memories (optional)\n            retrieval_query: Custom search query (defaults to user_input)\n            top_k: Number of memories to retrieve\n            event_timestamp: Optional timestamp for the event\n\n        Returns:\n            Tuple of (retrieved_memories, agent_response, created_event)\n\n        Example:\n            def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n                # Format context from memories\n                context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n                # Call your LLM (Bedrock, OpenAI, etc.)\n                response = bedrock.invoke_model(\n                    messages=[\n                        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                        {\"role\": \"user\", \"content\": user_input}\n                    ]\n                )\n                return response['content']\n\n            memories, response, event = client.process_turn_with_llm(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                user_input=\"What did we discuss yesterday?\",\n                llm_callback=my_llm,\n                retrieval_namespace=\"support/facts/{sessionId}\"\n            )\n        \"\"\"\n        # Step 1: Retrieve relevant memories\n        retrieved_memories = []\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n            logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n        # Step 2: Invoke LLM callback\n        try:\n            agent_response = llm_callback(user_input, retrieved_memories)\n            if not isinstance(agent_response, str):\n                raise ValueError(\"LLM callback must return a string response\")\n            logger.info(\"LLM callback generated response\")\n        except Exception as e:\n            logger.error(\"LLM callback failed: %s\", e)\n            raise\n\n        # Step 3: Save the conversation turn\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Completed full conversation turn with LLM\")\n        return retrieved_memories, agent_response, event\n\n    def list_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_events: bool = False,\n        max_results: int = 100,\n        include_payload: bool = True,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all events in a session with pagination support.\n\n        This method provides direct access to the raw events API, allowing developers\n        to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Optional branch name to filter events (None for all branches)\n            include_parent_events: Whether to include parent branch events (only applies with branch_name)\n            max_results: Maximum number of events to return\n            include_payload: Whether to include event payloads in response\n\n        Returns:\n            List of event dictionaries in chronological order\n\n        Example:\n            # Get all events\n            events = client.list_events(memory_id, actor_id, session_id)\n\n            # Get only main branch events\n            main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n            # Get events from a specific branch\n            branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n        \"\"\"\n        try:\n            all_events = []\n            next_token = None\n\n            while len(all_events) &lt; max_results:\n                params = {\n                    \"memoryId\": memory_id,\n                    \"actorId\": actor_id,\n                    \"sessionId\": session_id,\n                    \"maxResults\": min(100, max_results - len(all_events)),\n                }\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                # Add branch filter if specified (but not for \"main\")\n                if branch_name and branch_name != \"main\":\n                    params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n                response = self.gmdp_client.list_events(**params)\n\n                events = response.get(\"events\", [])\n                all_events.extend(events)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(all_events) &gt;= max_results:\n                    break\n\n            logger.info(\"Retrieved total of %d events\", len(all_events))\n            return all_events[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list events: %s\", e)\n            raise\n\n    def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all branches in a session.\n\n        This method handles pagination automatically and provides a structured view\n        of all conversation branches, which would require complex pagination and\n        grouping logic if done with raw boto3 calls.\n\n        Returns:\n            List of branch information including name and root event\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            branches = {}\n            main_branch_events = []\n\n            for event in all_events:\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    if branch_name not in branches:\n                        branches[branch_name] = {\n                            \"name\": branch_name,\n                            \"rootEventId\": branch_info.get(\"rootEventId\"),\n                            \"firstEventId\": event[\"eventId\"],\n                            \"eventCount\": 1,\n                            \"created\": event[\"eventTimestamp\"],\n                        }\n                    else:\n                        branches[branch_name][\"eventCount\"] += 1\n                else:\n                    main_branch_events.append(event)\n\n            # Build result list\n            result = []\n\n            # Only add main branch if there are actual events\n            if main_branch_events:\n                result.append(\n                    {\n                        \"name\": \"main\",\n                        \"rootEventId\": None,\n                        \"firstEventId\": main_branch_events[0][\"eventId\"],\n                        \"eventCount\": len(main_branch_events),\n                        \"created\": main_branch_events[0][\"eventTimestamp\"],\n                    }\n                )\n\n            # Add other branches\n            result.extend(list(branches.values()))\n\n            logger.info(\"Found %d branches in session %s\", len(result), session_id)\n            return result\n\n        except ClientError as e:\n            logger.error(\"Failed to list branches: %s\", e)\n            raise\n\n    def list_branch_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_events: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List events in a specific branch.\n\n        This method provides complex filtering and pagination that would require\n        significant boilerplate code with raw boto3. It handles:\n        - Automatic pagination across multiple API calls\n        - Branch filtering with parent event inclusion logic\n        - Main branch isolation (events without branch info)\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch name (None for main branch)\n            include_parent_events: Whether to include events from parent branches\n            max_results: Maximum events to return\n\n        Returns:\n            List of events in the branch\n        \"\"\"\n        try:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results),\n            }\n\n            # Only add filter when we have a specific branch name\n            if branch_name:\n                params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n            response = self.gmdp_client.list_events(**params)\n            events = response.get(\"events\", [])\n\n            # Handle pagination\n            next_token = response.get(\"nextToken\")\n            while next_token and len(events) &lt; max_results:\n                params[\"nextToken\"] = next_token\n                params[\"maxResults\"] = min(100, max_results - len(events))\n                response = self.gmdp_client.list_events(**params)\n                events.extend(response.get(\"events\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Filter for main branch if no branch specified\n            if not branch_name:\n                events = [e for e in events if not e.get(\"branch\")]\n\n            logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n            return events\n\n        except ClientError as e:\n            logger.error(\"Failed to list branch events: %s\", e)\n            raise\n\n    def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a tree structure of the conversation with all branches.\n\n        This method transforms a flat list of events into a hierarchical tree structure,\n        providing visualization-ready data that would be complex to build from raw events.\n        It handles:\n        - Full pagination to get all events\n        - Grouping by branches\n        - Message summarization\n        - Tree structure building\n\n        Returns:\n            Dictionary representing the conversation tree structure\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            # Build tree structure\n            tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n            # Group events by branch\n            for event in all_events:\n                event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n                # Extract message summaries\n                if \"payload\" in event:\n                    for payload_item in event.get(\"payload\", []):\n                        if \"conversational\" in payload_item:\n                            conv = payload_item[\"conversational\"]\n                            event_summary[\"messages\"].append(\n                                {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                            )\n\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                    if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                        tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                    tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n                else:\n                    tree[\"main_branch\"][\"events\"].append(event_summary)\n\n            logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n            return tree\n\n        except ClientError as e:\n            logger.error(\"Failed to build conversation tree: %s\", e)\n            raise\n\n    def merge_branch_context(\n        self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all messages from a branch for context building.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch to get context from\n            include_parent: Whether to include parent branch events\n\n        Returns:\n            List of all messages in chronological order\n        \"\"\"\n        events = self.list_branch_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_events=include_parent,\n            max_results=100,\n        )\n\n        messages = []\n        for event in events:\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        messages.append(\n                            {\n                                \"timestamp\": event[\"eventTimestamp\"],\n                                \"eventId\": event[\"eventId\"],\n                                \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                                \"role\": conv.get(\"role\"),\n                                \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                            }\n                        )\n\n        # Sort by timestamp\n        messages.sort(key=lambda x: x[\"timestamp\"])\n\n        logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n        return messages\n\n    def get_last_k_turns(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        k: int = 5,\n        branch_name: Optional[str] = None,\n        include_branches: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Get the last K conversation turns.\n\n        A \"turn\" typically consists of a user message followed by assistant response(s).\n        This method groups messages into logical turns for easier processing.\n\n        Returns:\n            List of turns, where each turn is a list of message dictionaries\n        \"\"\"\n        try:\n            # Use the new list_events method\n            events = self.list_events(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                branch_name=branch_name,\n                include_parent_events=False,\n                max_results=max_results,\n            )\n\n            if not events:\n                return []\n\n            # Process events to group into turns\n            turns = []\n            current_turn = []\n\n            # Process events in chronological order\n            for _, event in enumerate(events):\n                if \"payload\" in event and event[\"payload\"]:\n                    for payload_item in event[\"payload\"]:\n                        if \"conversational\" in payload_item:\n                            role = payload_item[\"conversational\"].get(\"role\")\n\n                            # Start a new turn when we see a USER message and already have messages\n                            if role == Role.USER.value and current_turn:\n                                turns.append(current_turn)\n                                current_turn = []\n\n                            current_turn.append(payload_item[\"conversational\"])\n\n            # Don't forget the last turn\n            if current_turn:\n                turns.append(current_turn)\n\n            # Return the last k turns\n            if len(turns) &gt; k:\n                result = turns[-k:]  # Get last k turns\n            else:\n                result = turns\n\n            return result\n\n        except ClientError as e:\n            logger.error(\"Failed to get last K turns: %s\", e)\n            raise\n\n    def fork_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        root_event_id: str,\n        branch_name: str,\n        new_messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n        try:\n            branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n            event = self.create_event(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                messages=new_messages,\n                branch=branch,\n                event_timestamp=event_timestamp,\n            )\n\n            logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to fork conversation: %s\", e)\n            raise\n\n    def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all strategies for a memory.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            memory = response[\"memory\"]\n\n            # Handle both old and new field names in response\n            strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n            # Normalize strategy fields\n            normalized_strategies = []\n            for strategy in strategies:\n                # Create normalized version with both old and new field names\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            return normalized_strategies\n        except ClientError as e:\n            logger.error(\"Failed to get memory strategies: %s\", e)\n            raise\n\n    def get_memory_status(self, memory_id: str) -&gt; str:\n        \"\"\"Get current memory status.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            return response[\"memory\"][\"status\"]\n        except ClientError as e:\n            logger.error(\"Failed to get memory status: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account.\"\"\"\n        try:\n            # Ensure max_results doesn't exceed API limit per request\n            results_per_request = min(max_results, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request)\n            memories = response.get(\"memories\", [])\n\n            next_token = response.get(\"nextToken\")\n            while next_token and len(memories) &lt; max_results:\n                remaining = max_results - len(memories)\n                results_per_request = min(remaining, 100)\n\n                response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n                memories.extend(response.get(\"memories\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Normalize memory summaries if they contain new field names\n            normalized_memories = []\n            for memory in memories[:max_results]:\n                normalized = memory.copy()\n                # Ensure both field name versions exist\n                if \"id\" in memory and \"memoryId\" not in normalized:\n                    normalized[\"memoryId\"] = memory[\"id\"]\n                elif \"memoryId\" in memory and \"id\" not in normalized:\n                    normalized[\"id\"] = memory[\"memoryId\"]\n                normalized_memories.append(normalized)\n\n            return normalized_memories\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\"\"\"\n        try:\n            response = self.gmcp_client.delete_memory(\n                memoryId=memory_id, clientToken=str(uuid.uuid4())\n            )  # Input uses old field name\n            logger.info(\"Deleted memory: %s\", memory_id)\n            return response\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory and wait for deletion to complete.\n\n        This method deletes a memory and polls until it's fully deleted,\n        ensuring clean resource cleanup.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between checks (default: 10)\n\n        Returns:\n            Final deletion response\n\n        Raises:\n            TimeoutError: If deletion doesn't complete within max_wait\n        \"\"\"\n        # Initiate deletion\n        response = self.delete_memory(memory_id)\n        logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                # Try to get the memory - if it doesn't exist, deletion is complete\n                self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                    return response\n                else:\n                    logger.error(\"Error checking memory status: %s\", e)\n                    raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n\n    def add_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SEMANTIC.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n        This addresses the issue where adding a strategy puts the memory into\n        CREATING state temporarily, preventing subsequent operations.\n        \"\"\"\n        # Add the strategy\n        self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_summary_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SUMMARY.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SUMMARY.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_summary_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_summary_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_user_preference_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.USER_PREFERENCE.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_user_preference_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_user_preference_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_custom_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy with prompts.\n\n        Args:\n            memory_id: Memory resource ID\n            name: Strategy name\n            extraction_config: Extraction configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            consolidation_config: Consolidation configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            description: Optional description\n            namespaces: Optional namespaces list\n        \"\"\"\n        strategy = {\n            StrategyType.CUSTOM.value: {\n                \"name\": name,\n                \"configuration\": {\n                    \"semanticOverride\": {\n                        \"extraction\": {\n                            \"appendToPrompt\": extraction_config[\"prompt\"],\n                            \"modelId\": extraction_config[\"modelId\"],\n                        },\n                        \"consolidation\": {\n                            \"appendToPrompt\": consolidation_config[\"prompt\"],\n                            \"modelId\": consolidation_config[\"modelId\"],\n                        },\n                    }\n                },\n            }\n        }\n\n        if description:\n            strategy[StrategyType.CUSTOM.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_custom_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_custom_semantic_strategy(\n            memory_id, name, extraction_config, consolidation_config, description, namespaces\n        )\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def modify_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Modify a strategy with full control over configuration.\"\"\"\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n        if description is not None:\n            modify_config[\"description\"] = description\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n\n    def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a strategy from a memory.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n\n    def update_memory_strategies(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n        try:\n            memory_strategies = {}\n\n            if add_strategies:\n                processed_add = self._add_default_namespaces(add_strategies)\n                memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n            if modify_strategies:\n                current_strategies = self.get_memory_strategies(memory_id)\n                strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n                modify_list = []\n                for strategy in modify_strategies:\n                    if \"memoryStrategyId\" not in strategy:  # Using old field name\n                        raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                    strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                    strategy_info = strategy_map.get(strategy_id)\n\n                    if not strategy_info:\n                        raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                    strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                    override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                    strategy_copy = copy.deepcopy(strategy)\n\n                    if \"configuration\" in strategy_copy:\n                        wrapped_config = self._wrap_configuration(\n                            strategy_copy[\"configuration\"], strategy_type, override_type\n                        )\n                        strategy_copy[\"configuration\"] = wrapped_config\n\n                    modify_list.append(strategy_copy)\n\n                memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n            if delete_strategy_ids:\n                delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n                memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n            if not memory_strategies:\n                raise ValueError(\"No strategy operations provided\")\n\n            response = self.gmcp_client.update_memory(\n                memoryId=memory_id,\n                memoryStrategies=memory_strategies,\n                clientToken=str(uuid.uuid4()),  # Using old field names for input\n            )\n\n            logger.info(\"Updated memory strategies for: %s\", memory_id)\n            memory = self._normalize_memory_response(response[\"memory\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory strategies: %s\", e)\n            raise\n\n    def update_memory_strategies_and_wait(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n        This method handles the temporary CREATING state that occurs when\n        updating strategies, preventing subsequent update errors.\n        \"\"\"\n        # Update strategies\n        self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def wait_for_memories(\n        self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n    ) -&gt; bool:\n        \"\"\"Wait for memory extraction to complete by polling.\n\n        IMPORTANT LIMITATIONS:\n        1. This method only works reliably on empty namespaces. If there are already\n           existing memories in the namespace, this method may return True immediately\n           even if new extractions haven't completed.\n        2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n           namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n           not \"support/facts/*\").\n\n        For subsequent extractions in populated namespaces, use a fixed wait time:\n            time.sleep(150)  # Wait 2.5 minutes for extraction\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace to check (no wildcards)\n            test_query: Query to test with (default: \"test\")\n            max_wait: Maximum seconds to wait (default: 180)\n            poll_interval: Seconds between checks (default: 15)\n\n        Returns:\n            True if memories found, False if timeout\n\n        Note:\n            This method will be deprecated in future versions once the API\n            provides extraction status or timestamps.\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return False\n\n        logger.warning(\n            \"wait_for_memories() only works reliably on empty namespaces. \"\n            \"For populated namespaces, consider using a fixed wait time instead.\"\n        )\n\n        logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n        start_time = time.time()\n        service_errors = 0\n\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n                if memories:\n                    logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                    return True\n\n                # Reset service error count on successful call\n                service_errors = 0\n\n            except Exception as e:\n                if \"ServiceException\" in str(e):\n                    service_errors += 1\n                    if service_errors &gt;= 3:\n                        logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n                logger.debug(\"Retrieval attempt failed: %s\", e)\n\n            if time.time() - start_time &lt; max_wait:\n                time.sleep(poll_interval)\n\n        logger.warning(\"No memories found after %d seconds\", max_wait)\n        if service_errors &gt; 0:\n            logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n        return False\n\n    def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory (without waiting).\n\n        WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n        Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n\n        Returns:\n            Updated memory response\n        \"\"\"\n        warnings.warn(\n            \"add_strategy() may leave memory in CREATING state. \"\n            \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        return self._add_strategy(memory_id, strategy)\n\n    # Private methods\n\n    def _normalize_memory_response(self, memory: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Normalize memory response to include both old and new field names.\n\n        The API returns new field names but SDK users might expect old ones.\n        This ensures compatibility by providing both.\n        \"\"\"\n        # Ensure both versions of memory ID exist\n        if \"id\" in memory and \"memoryId\" not in memory:\n            memory[\"memoryId\"] = memory[\"id\"]\n        elif \"memoryId\" in memory and \"id\" not in memory:\n            memory[\"id\"] = memory[\"memoryId\"]\n\n        # Ensure both versions of strategies exist\n        if \"strategies\" in memory and \"memoryStrategies\" not in memory:\n            memory[\"memoryStrategies\"] = memory[\"strategies\"]\n        elif \"memoryStrategies\" in memory and \"strategies\" not in memory:\n            memory[\"strategies\"] = memory[\"memoryStrategies\"]\n\n        # Normalize strategies within memory\n        if \"strategies\" in memory:\n            normalized_strategies = []\n            for strategy in memory[\"strategies\"]:\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist for strategies\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            memory[\"strategies\"] = normalized_strategies\n            memory[\"memoryStrategies\"] = normalized_strategies\n\n        return memory\n\n    def _add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Internal method to add a single strategy.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, add_strategies=[strategy])\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state after strategy update.\"\"\"\n        logger.info(\"Waiting for memory %s to return to ACTIVE state...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is ACTIVE again (took %d seconds)\", memory_id, elapsed)\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory update failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not return to ACTIVE state within %d seconds\" % (memory_id, max_wait))\n\n    def _add_default_namespaces(self, strategies: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Add default namespaces to strategies that don't have them.\"\"\"\n        processed = []\n\n        for strategy in strategies:\n            strategy_copy = copy.deepcopy(strategy)\n\n            strategy_type_key = list(strategy.keys())[0]\n            strategy_config = strategy_copy[strategy_type_key]\n\n            if \"namespaces\" not in strategy_config:\n                strategy_type = StrategyType(strategy_type_key)\n                strategy_config[\"namespaces\"] = DEFAULT_NAMESPACES.get(strategy_type, [\"custom/{actorId}/{sessionId}\"])\n\n            self._validate_strategy_config(strategy_copy, strategy_type_key)\n\n            processed.append(strategy_copy)\n\n        return processed\n\n    def _validate_namespace(self, namespace: str) -&gt; bool:\n        \"\"\"Validate namespace format - basic check only.\"\"\"\n        # Only check for template variables in namespace definition\n        # Note: Using memoryStrategyId (old name) as it's still used in input parameters\n        if \"{\" in namespace and not (\n            \"{actorId}\" in namespace or \"{sessionId}\" in namespace or \"{memoryStrategyId}\" in namespace\n        ):\n            logger.warning(\"Namespace with templates should contain valid variables: %s\", namespace)\n\n        return True\n\n    def _validate_strategy_config(self, strategy: Dict[str, Any], strategy_type: str) -&gt; None:\n        \"\"\"Validate strategy configuration parameters.\"\"\"\n        strategy_config = strategy[strategy_type]\n\n        namespaces = strategy_config.get(\"namespaces\", [])\n        for namespace in namespaces:\n            self._validate_namespace(namespace)\n\n    def _wrap_configuration(\n        self, config: Dict[str, Any], strategy_type: str, override_type: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wrap configuration based on strategy type.\"\"\"\n        wrapped_config = {}\n\n        if \"extraction\" in config:\n            extraction = config[\"extraction\"]\n\n            if any(key in extraction for key in [\"triggerEveryNMessages\", \"historicalContextWindowSize\"]):\n                strategy_type_enum = MemoryStrategyTypeEnum(strategy_type)\n\n                if strategy_type == \"SEMANTIC\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"USER_PREFERENCE\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_type in [\"SEMANTIC_OVERRIDE\", \"USER_PREFERENCE_OVERRIDE\"]:\n                        wrapped_config[\"extraction\"] = {\n                            \"customExtractionConfiguration\": {CUSTOM_EXTRACTION_WRAPPER_KEYS[override_enum]: extraction}\n                        }\n            else:\n                wrapped_config[\"extraction\"] = extraction\n\n        if \"consolidation\" in config:\n            consolidation = config[\"consolidation\"]\n\n            raw_keys = [\"triggerEveryNMessages\", \"appendToPrompt\", \"modelId\"]\n            if any(key in consolidation for key in raw_keys):\n                if strategy_type == \"SUMMARIZATION\":\n                    if \"triggerEveryNMessages\" in consolidation:\n                        wrapped_config[\"consolidation\"] = {\n                            \"summaryConsolidationConfiguration\": {\n                                \"triggerEveryNMessages\": consolidation[\"triggerEveryNMessages\"]\n                            }\n                        }\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_enum in CUSTOM_CONSOLIDATION_WRAPPER_KEYS:\n                        wrapped_config[\"consolidation\"] = {\n                            \"customConsolidationConfiguration\": {\n                                CUSTOM_CONSOLIDATION_WRAPPER_KEYS[override_enum]: consolidation\n                            }\n                        }\n            else:\n                wrapped_config[\"consolidation\"] = consolidation\n\n        return wrapped_config\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__init__","title":"<code>__init__(region_name=None)</code>","text":"<p>Initialize the Memory client.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def __init__(self, region_name: Optional[str] = None):\n    \"\"\"Initialize the Memory client.\"\"\"\n    self.region_name = boto3.Session().region_name or region_name or \"us-west-2\"\n\n    self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n    self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n    logger.info(\n        \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n        self.gmcp_client.meta.region_name,\n        self.gmdp_client.meta.region_name,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy","title":"<code>add_custom_semantic_strategy(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None)</code>","text":"<p>Add a custom semantic strategy with prompts.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>name</code> <code>str</code> <p>Strategy name</p> required <code>extraction_config</code> <code>Dict[str, Any]</code> <p>Extraction configuration with prompt and model:</p> required <code>consolidation_config</code> <code>Dict[str, Any]</code> <p>Consolidation configuration with prompt and model:</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional namespaces list</p> <code>None</code> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy with prompts.\n\n    Args:\n        memory_id: Memory resource ID\n        name: Strategy name\n        extraction_config: Extraction configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        consolidation_config: Consolidation configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        description: Optional description\n        namespaces: Optional namespaces list\n    \"\"\"\n    strategy = {\n        StrategyType.CUSTOM.value: {\n            \"name\": name,\n            \"configuration\": {\n                \"semanticOverride\": {\n                    \"extraction\": {\n                        \"appendToPrompt\": extraction_config[\"prompt\"],\n                        \"modelId\": extraction_config[\"modelId\"],\n                    },\n                    \"consolidation\": {\n                        \"appendToPrompt\": consolidation_config[\"prompt\"],\n                        \"modelId\": consolidation_config[\"modelId\"],\n                    },\n                }\n            },\n        }\n    }\n\n    if description:\n        strategy[StrategyType.CUSTOM.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy_and_wait","title":"<code>add_custom_semantic_strategy_and_wait(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a custom semantic strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_custom_semantic_strategy(\n        memory_id, name, extraction_config, consolidation_config, description, namespaces\n    )\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy","title":"<code>add_semantic_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a semantic memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SEMANTIC.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy_and_wait","title":"<code>add_semantic_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a semantic strategy and wait for memory to return to ACTIVE state.</p> <p>This addresses the issue where adding a strategy puts the memory into CREATING state temporarily, preventing subsequent operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n    This addresses the issue where adding a strategy puts the memory into\n    CREATING state temporarily, preventing subsequent operations.\n    \"\"\"\n    # Add the strategy\n    self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_strategy","title":"<code>add_strategy(memory_id, strategy)</code>","text":"<p>Add a strategy to a memory (without waiting).</p> <p>WARNING: After adding a strategy, the memory enters CREATING state temporarily. Use add_*_strategy_and_wait() methods instead to avoid errors.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory response</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory (without waiting).\n\n    WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n    Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n\n    Returns:\n        Updated memory response\n    \"\"\"\n    warnings.warn(\n        \"add_strategy() may leave memory in CREATING state. \"\n        \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n        UserWarning,\n        stacklevel=2,\n    )\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy","title":"<code>add_summary_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a summary memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SUMMARY.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SUMMARY.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy_and_wait","title":"<code>add_summary_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a summary strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_summary_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy","title":"<code>add_user_preference_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a user preference memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.USER_PREFERENCE.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy_and_wait","title":"<code>add_user_preference_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a user preference strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_user_preference_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event","title":"<code>create_event(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>Save an event of an agent interaction or conversation with a user.</p> <p>This is the basis of short-term memory. If you configured your Memory resource to have MemoryStrategies, then events that are saved in short-term memory via create_event will be used to extract long-term memory records.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (could be id of your user or an agent)</p> required <code>session_id</code> <code>str</code> <p>Session identifier (meant to logically group a series of events)</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}    A branch is used when you want to have a different history of events.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example <p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"Today is sunny\", \"ASSISTANT\")     ] ) root_event_id = event.get(\"eventId\") print(event)</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_event(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Save an event of an agent interaction or conversation with a user.\n\n    This is the basis of short-term memory. If you configured your Memory resource\n    to have MemoryStrategies, then events that are saved in short-term memory via\n    create_event will be used to extract long-term memory records.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (could be id of your user or an agent)\n        session_id: Session identifier (meant to logically group a series of events)\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n               A branch is used when you want to have a different history of events.\n\n    Returns:\n        Created event\n\n    Example:\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"Today is sunny\", \"ASSISTANT\")\n            ]\n        )\n        root_event_id = event.get(\"eventId\")\n        print(event)\n\n        # Continue the conversation\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"How about the weather tomorrow\", \"USER\"),\n                (\"Tomorrow is cold!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n\n        # branch the conversation so that the previous message is not part of the history\n        # (suppose you did not mean to ask about the weather tomorrow and want to undo\n        # that, and replace with a new message)\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n            messages=[\n                (\"How about the weather a year from now\", \"USER\"),\n                (\"I can't predict that far into the future!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        payload = []\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--continue-the-conversation","title":"Continue the conversation","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"How about the weather tomorrow\", \"USER\"),         (\"Tomorrow is cold!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--branch-the-conversation-so-that-the-previous-message-is-not-part-of-the-history","title":"branch the conversation so that the previous message is not part of the history","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--suppose-you-did-not-mean-to-ask-about-the-weather-tomorrow-and-want-to-undo","title":"(suppose you did not mean to ask about the weather tomorrow and want to undo","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--that-and-replace-with-a-new-message","title":"that, and replace with a new message)","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},     messages=[         (\"How about the weather a year from now\", \"USER\"),         (\"I can't predict that far into the future!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory","title":"<code>create_memory(name, strategies=None, description=None, event_expiry_days=90, memory_execution_role_arn=None)</code>","text":"<p>Create a memory with simplified configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory with simplified configuration.\"\"\"\n    if strategies is None:\n        strategies = []\n\n    try:\n        processed_strategies = self._add_default_namespaces(strategies)\n\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"memoryStrategies\": processed_strategies,  # Using old field name for input\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description is not None:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        response = self.gmcp_client.create_memory(**params)\n\n        memory = response[\"memory\"]\n        # Normalize response to handle new field names\n        memory = self._normalize_memory_response(memory)\n\n        logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory_and_wait","title":"<code>create_memory_and_wait(name, strategies, description=None, event_expiry_days=90, memory_execution_role_arn=None, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory and wait for it to become ACTIVE.</p> <p>This method creates a memory and polls until it reaches ACTIVE status, providing a convenient way to ensure the memory is ready for use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>strategies</code> <code>List[Dict[str, Any]]</code> <p>List of strategy configurations</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object in ACTIVE status</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If memory doesn't become ACTIVE within max_wait</p> <code>RuntimeError</code> <p>If memory creation fails</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory_and_wait(\n    self,\n    name: str,\n    strategies: List[Dict[str, Any]],\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory and wait for it to become ACTIVE.\n\n    This method creates a memory and polls until it reaches ACTIVE status,\n    providing a convenient way to ensure the memory is ready for use.\n\n    Args:\n        name: Name for the memory resource\n        strategies: List of strategy configurations\n        description: Optional description\n        event_expiry_days: How long to retain events (default: 90 days)\n        memory_execution_role_arn: IAM role ARN for memory execution\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between status checks (default: 10)\n\n    Returns:\n        Created memory object in ACTIVE status\n\n    Raises:\n        TimeoutError: If memory doesn't become ACTIVE within max_wait\n        RuntimeError: If memory creation fails\n    \"\"\"\n    # Create the memory\n    memory = self.create_memory(\n        name=name,\n        strategies=strategies,\n        description=description,\n        event_expiry_days=event_expiry_days,\n        memory_execution_role_arn=memory_execution_role_arn,\n    )\n\n    memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n    if memory_id is None:\n        memory_id = \"\"\n    logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            status = self.get_memory_status(memory_id)\n\n            if status == MemoryStatus.ACTIVE.value:\n                logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                # Get fresh memory details\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                memory = self._normalize_memory_response(response[\"memory\"])\n                return memory\n            elif status == MemoryStatus.FAILED.value:\n                # Get failure reason if available\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n            else:\n                logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n        except ClientError as e:\n            logger.error(\"Error checking memory status: %s\", e)\n            raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory","title":"<code>delete_memory(memory_id)</code>","text":"<p>Delete a memory resource.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\"\"\"\n    try:\n        response = self.gmcp_client.delete_memory(\n            memoryId=memory_id, clientToken=str(uuid.uuid4())\n        )  # Input uses old field name\n        logger.info(\"Deleted memory: %s\", memory_id)\n        return response\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory_and_wait","title":"<code>delete_memory_and_wait(memory_id, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory and wait for deletion to complete.</p> <p>This method deletes a memory and polls until it's fully deleted, ensuring clean resource cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Final deletion response</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If deletion doesn't complete within max_wait</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory and wait for deletion to complete.\n\n    This method deletes a memory and polls until it's fully deleted,\n    ensuring clean resource cleanup.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between checks (default: 10)\n\n    Returns:\n        Final deletion response\n\n    Raises:\n        TimeoutError: If deletion doesn't complete within max_wait\n    \"\"\"\n    # Initiate deletion\n    response = self.delete_memory(memory_id)\n    logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            # Try to get the memory - if it doesn't exist, deletion is complete\n            self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n        except ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                return response\n            else:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_strategy","title":"<code>delete_strategy(memory_id, strategy_id)</code>","text":"<p>Delete a strategy from a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a strategy from a memory.\"\"\"\n    return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.fork_conversation","title":"<code>fork_conversation(memory_id, actor_id, session_id, root_event_id, branch_name, new_messages, event_timestamp=None)</code>","text":"<p>Fork a conversation from a specific event to create a new branch.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def fork_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    root_event_id: str,\n    branch_name: str,\n    new_messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n    try:\n        branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=new_messages,\n            branch=branch,\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to fork conversation: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_conversation_tree","title":"<code>get_conversation_tree(memory_id, actor_id, session_id)</code>","text":"<p>Get a tree structure of the conversation with all branches.</p> <p>This method transforms a flat list of events into a hierarchical tree structure, providing visualization-ready data that would be complex to build from raw events. It handles: - Full pagination to get all events - Grouping by branches - Message summarization - Tree structure building</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing the conversation tree structure</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a tree structure of the conversation with all branches.\n\n    This method transforms a flat list of events into a hierarchical tree structure,\n    providing visualization-ready data that would be complex to build from raw events.\n    It handles:\n    - Full pagination to get all events\n    - Grouping by branches\n    - Message summarization\n    - Tree structure building\n\n    Returns:\n        Dictionary representing the conversation tree structure\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        # Build tree structure\n        tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n        # Group events by branch\n        for event in all_events:\n            event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n            # Extract message summaries\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        event_summary[\"messages\"].append(\n                            {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                        )\n\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                    tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n            else:\n                tree[\"main_branch\"][\"events\"].append(event_summary)\n\n        logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n        return tree\n\n    except ClientError as e:\n        logger.error(\"Failed to build conversation tree: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_last_k_turns","title":"<code>get_last_k_turns(memory_id, actor_id, session_id, k=5, branch_name=None, include_branches=False, max_results=100)</code>","text":"<p>Get the last K conversation turns.</p> <p>A \"turn\" typically consists of a user message followed by assistant response(s). This method groups messages into logical turns for easier processing.</p> <p>Returns:</p> Type Description <code>List[List[Dict[str, Any]]]</code> <p>List of turns, where each turn is a list of message dictionaries</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_last_k_turns(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    k: int = 5,\n    branch_name: Optional[str] = None,\n    include_branches: bool = False,\n    max_results: int = 100,\n) -&gt; List[List[Dict[str, Any]]]:\n    \"\"\"Get the last K conversation turns.\n\n    A \"turn\" typically consists of a user message followed by assistant response(s).\n    This method groups messages into logical turns for easier processing.\n\n    Returns:\n        List of turns, where each turn is a list of message dictionaries\n    \"\"\"\n    try:\n        # Use the new list_events method\n        events = self.list_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_events=False,\n            max_results=max_results,\n        )\n\n        if not events:\n            return []\n\n        # Process events to group into turns\n        turns = []\n        current_turn = []\n\n        # Process events in chronological order\n        for _, event in enumerate(events):\n            if \"payload\" in event and event[\"payload\"]:\n                for payload_item in event[\"payload\"]:\n                    if \"conversational\" in payload_item:\n                        role = payload_item[\"conversational\"].get(\"role\")\n\n                        # Start a new turn when we see a USER message and already have messages\n                        if role == Role.USER.value and current_turn:\n                            turns.append(current_turn)\n                            current_turn = []\n\n                        current_turn.append(payload_item[\"conversational\"])\n\n        # Don't forget the last turn\n        if current_turn:\n            turns.append(current_turn)\n\n        # Return the last k turns\n        if len(turns) &gt; k:\n            result = turns[-k:]  # Get last k turns\n        else:\n            result = turns\n\n        return result\n\n    except ClientError as e:\n        logger.error(\"Failed to get last K turns: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_status","title":"<code>get_memory_status(memory_id)</code>","text":"<p>Get current memory status.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_status(self, memory_id: str) -&gt; str:\n    \"\"\"Get current memory status.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        return response[\"memory\"][\"status\"]\n    except ClientError as e:\n        logger.error(\"Failed to get memory status: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_strategies","title":"<code>get_memory_strategies(memory_id)</code>","text":"<p>Get all strategies for a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all strategies for a memory.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        memory = response[\"memory\"]\n\n        # Handle both old and new field names in response\n        strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n        # Normalize strategy fields\n        normalized_strategies = []\n        for strategy in strategies:\n            # Create normalized version with both old and new field names\n            normalized = strategy.copy()\n\n            # Ensure both field name versions exist\n            if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n            elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n            if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n            elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n            normalized_strategies.append(normalized)\n\n        return normalized_strategies\n    except ClientError as e:\n        logger.error(\"Failed to get memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branch_events","title":"<code>list_branch_events(memory_id, actor_id, session_id, branch_name=None, include_parent_events=False, max_results=100)</code>","text":"<p>List events in a specific branch.</p> <p>This method provides complex filtering and pagination that would require significant boilerplate code with raw boto3. It handles: - Automatic pagination across multiple API calls - Branch filtering with parent event inclusion logic - Main branch isolation (events without branch info)</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Branch name (None for main branch)</p> <code>None</code> <code>include_parent_events</code> <code>bool</code> <p>Whether to include events from parent branches</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum events to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of events in the branch</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branch_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_events: bool = False,\n    max_results: int = 100,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List events in a specific branch.\n\n    This method provides complex filtering and pagination that would require\n    significant boilerplate code with raw boto3. It handles:\n    - Automatic pagination across multiple API calls\n    - Branch filtering with parent event inclusion logic\n    - Main branch isolation (events without branch info)\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch name (None for main branch)\n        include_parent_events: Whether to include events from parent branches\n        max_results: Maximum events to return\n\n    Returns:\n        List of events in the branch\n    \"\"\"\n    try:\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"maxResults\": min(100, max_results),\n        }\n\n        # Only add filter when we have a specific branch name\n        if branch_name:\n            params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n        response = self.gmdp_client.list_events(**params)\n        events = response.get(\"events\", [])\n\n        # Handle pagination\n        next_token = response.get(\"nextToken\")\n        while next_token and len(events) &lt; max_results:\n            params[\"nextToken\"] = next_token\n            params[\"maxResults\"] = min(100, max_results - len(events))\n            response = self.gmdp_client.list_events(**params)\n            events.extend(response.get(\"events\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Filter for main branch if no branch specified\n        if not branch_name:\n            events = [e for e in events if not e.get(\"branch\")]\n\n        logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n        return events\n\n    except ClientError as e:\n        logger.error(\"Failed to list branch events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branches","title":"<code>list_branches(memory_id, actor_id, session_id)</code>","text":"<p>List all branches in a session.</p> <p>This method handles pagination automatically and provides a structured view of all conversation branches, which would require complex pagination and grouping logic if done with raw boto3 calls.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of branch information including name and root event</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all branches in a session.\n\n    This method handles pagination automatically and provides a structured view\n    of all conversation branches, which would require complex pagination and\n    grouping logic if done with raw boto3 calls.\n\n    Returns:\n        List of branch information including name and root event\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        branches = {}\n        main_branch_events = []\n\n        for event in all_events:\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                if branch_name not in branches:\n                    branches[branch_name] = {\n                        \"name\": branch_name,\n                        \"rootEventId\": branch_info.get(\"rootEventId\"),\n                        \"firstEventId\": event[\"eventId\"],\n                        \"eventCount\": 1,\n                        \"created\": event[\"eventTimestamp\"],\n                    }\n                else:\n                    branches[branch_name][\"eventCount\"] += 1\n            else:\n                main_branch_events.append(event)\n\n        # Build result list\n        result = []\n\n        # Only add main branch if there are actual events\n        if main_branch_events:\n            result.append(\n                {\n                    \"name\": \"main\",\n                    \"rootEventId\": None,\n                    \"firstEventId\": main_branch_events[0][\"eventId\"],\n                    \"eventCount\": len(main_branch_events),\n                    \"created\": main_branch_events[0][\"eventTimestamp\"],\n                }\n            )\n\n        # Add other branches\n        result.extend(list(branches.values()))\n\n        logger.info(\"Found %d branches in session %s\", len(result), session_id)\n        return result\n\n    except ClientError as e:\n        logger.error(\"Failed to list branches: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events","title":"<code>list_events(memory_id, actor_id, session_id, branch_name=None, include_parent_events=False, max_results=100, include_payload=True)</code>","text":"<p>List all events in a session with pagination support.</p> <p>This method provides direct access to the raw events API, allowing developers to retrieve all events without the turn grouping logic of get_last_k_turns.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Optional branch name to filter events (None for all branches)</p> <code>None</code> <code>include_parent_events</code> <code>bool</code> <p>Whether to include parent branch events (only applies with branch_name)</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum number of events to return</p> <code>100</code> <code>include_payload</code> <code>bool</code> <p>Whether to include event payloads in response</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of event dictionaries in chronological order</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_events: bool = False,\n    max_results: int = 100,\n    include_payload: bool = True,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all events in a session with pagination support.\n\n    This method provides direct access to the raw events API, allowing developers\n    to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Optional branch name to filter events (None for all branches)\n        include_parent_events: Whether to include parent branch events (only applies with branch_name)\n        max_results: Maximum number of events to return\n        include_payload: Whether to include event payloads in response\n\n    Returns:\n        List of event dictionaries in chronological order\n\n    Example:\n        # Get all events\n        events = client.list_events(memory_id, actor_id, session_id)\n\n        # Get only main branch events\n        main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n        # Get events from a specific branch\n        branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n    \"\"\"\n    try:\n        all_events = []\n        next_token = None\n\n        while len(all_events) &lt; max_results:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results - len(all_events)),\n            }\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            # Add branch filter if specified (but not for \"main\")\n            if branch_name and branch_name != \"main\":\n                params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n            response = self.gmdp_client.list_events(**params)\n\n            events = response.get(\"events\", [])\n            all_events.extend(events)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(all_events) &gt;= max_results:\n                break\n\n        logger.info(\"Retrieved total of %d events\", len(all_events))\n        return all_events[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-all-events","title":"Get all events","text":"<p>events = client.list_events(memory_id, actor_id, session_id)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-only-main-branch-events","title":"Get only main branch events","text":"<p>main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-events-from-a-specific-branch","title":"Get events from a specific branch","text":"<p>branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account.\"\"\"\n    try:\n        # Ensure max_results doesn't exceed API limit per request\n        results_per_request = min(max_results, 100)\n\n        response = self.gmcp_client.list_memories(maxResults=results_per_request)\n        memories = response.get(\"memories\", [])\n\n        next_token = response.get(\"nextToken\")\n        while next_token and len(memories) &lt; max_results:\n            remaining = max_results - len(memories)\n            results_per_request = min(remaining, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n            memories.extend(response.get(\"memories\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Normalize memory summaries if they contain new field names\n        normalized_memories = []\n        for memory in memories[:max_results]:\n            normalized = memory.copy()\n            # Ensure both field name versions exist\n            if \"id\" in memory and \"memoryId\" not in normalized:\n                normalized[\"memoryId\"] = memory[\"id\"]\n            elif \"memoryId\" in memory and \"id\" not in normalized:\n                normalized[\"id\"] = memory[\"memoryId\"]\n            normalized_memories.append(normalized)\n\n        return normalized_memories\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.merge_branch_context","title":"<code>merge_branch_context(memory_id, actor_id, session_id, branch_name, include_parent=True)</code>","text":"<p>Get all messages from a branch for context building.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>str</code> <p>Branch to get context from</p> required <code>include_parent</code> <code>bool</code> <p>Whether to include parent branch events</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of all messages in chronological order</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def merge_branch_context(\n    self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all messages from a branch for context building.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch to get context from\n        include_parent: Whether to include parent branch events\n\n    Returns:\n        List of all messages in chronological order\n    \"\"\"\n    events = self.list_branch_events(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        branch_name=branch_name,\n        include_parent_events=include_parent,\n        max_results=100,\n    )\n\n    messages = []\n    for event in events:\n        if \"payload\" in event:\n            for payload_item in event.get(\"payload\", []):\n                if \"conversational\" in payload_item:\n                    conv = payload_item[\"conversational\"]\n                    messages.append(\n                        {\n                            \"timestamp\": event[\"eventTimestamp\"],\n                            \"eventId\": event[\"eventId\"],\n                            \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                            \"role\": conv.get(\"role\"),\n                            \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                        }\n                    )\n\n    # Sort by timestamp\n    messages.sort(key=lambda x: x[\"timestamp\"])\n\n    logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n    return messages\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.modify_strategy","title":"<code>modify_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None)</code>","text":"<p>Modify a strategy with full control over configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def modify_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Modify a strategy with full control over configuration.\"\"\"\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n    if description is not None:\n        modify_config[\"description\"] = description\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn","title":"<code>process_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None, retrieval_namespace=None, retrieval_query=None, top_k=3)</code>","text":"<p>DEPRECATED: Use retrieve_memories() and save_conversation() separately.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n    \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"process_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    retrieved_memories = []\n\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n\n    event = self.save_turn(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        user_input=user_input,\n        agent_response=agent_response,\n        event_timestamp=event_timestamp,\n    )\n\n    return retrieved_memories, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn_with_llm","title":"<code>process_turn_with_llm(memory_id, actor_id, session_id, user_input, llm_callback, retrieval_namespace=None, retrieval_query=None, top_k=3, event_timestamp=None)</code>","text":"<p>Complete conversation turn with LLM callback integration.</p> <p>This method combines memory retrieval, LLM invocation, and response storage in a single call using a callback pattern.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (e.g., \"user-123\")</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>user_input</code> <code>str</code> <p>The user's message</p> required <code>llm_callback</code> <code>Callable[[str, List[Dict[str, Any]]], str]</code> <p>Function that takes (user_input, memories) and returns agent_response          The callback receives the user input and retrieved memories,          and should return the agent's response string</p> required <code>retrieval_namespace</code> <code>Optional[str]</code> <p>Namespace to search for memories (optional)</p> <code>None</code> <code>retrieval_query</code> <code>Optional[str]</code> <p>Custom search query (defaults to user_input)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of memories to retrieve</p> <code>3</code> <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], str, Dict[str, Any]]</code> <p>Tuple of (retrieved_memories, agent_response, created_event)</p> Example <p>def my_llm(user_input: str, memories: List[Dict]) -&gt; str:     # Format context from memories     context = \"\\n\".join([m['content']['text'] for m in memories])</p> <pre><code># Call your LLM (Bedrock, OpenAI, etc.)\nresponse = bedrock.invoke_model(\n    messages=[\n        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n        {\"role\": \"user\", \"content\": user_input}\n    ]\n)\nreturn response['content']\n</code></pre> <p>memories, response, event = client.process_turn_with_llm(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     user_input=\"What did we discuss yesterday?\",     llm_callback=my_llm,     retrieval_namespace=\"support/facts/{sessionId}\" )</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn_with_llm(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n    r\"\"\"Complete conversation turn with LLM callback integration.\n\n    This method combines memory retrieval, LLM invocation, and response storage\n    in a single call using a callback pattern.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (e.g., \"user-123\")\n        session_id: Session identifier\n        user_input: The user's message\n        llm_callback: Function that takes (user_input, memories) and returns agent_response\n                     The callback receives the user input and retrieved memories,\n                     and should return the agent's response string\n        retrieval_namespace: Namespace to search for memories (optional)\n        retrieval_query: Custom search query (defaults to user_input)\n        top_k: Number of memories to retrieve\n        event_timestamp: Optional timestamp for the event\n\n    Returns:\n        Tuple of (retrieved_memories, agent_response, created_event)\n\n    Example:\n        def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n            # Format context from memories\n            context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n            # Call your LLM (Bedrock, OpenAI, etc.)\n            response = bedrock.invoke_model(\n                messages=[\n                    {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                    {\"role\": \"user\", \"content\": user_input}\n                ]\n            )\n            return response['content']\n\n        memories, response, event = client.process_turn_with_llm(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            user_input=\"What did we discuss yesterday?\",\n            llm_callback=my_llm,\n            retrieval_namespace=\"support/facts/{sessionId}\"\n        )\n    \"\"\"\n    # Step 1: Retrieve relevant memories\n    retrieved_memories = []\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n        logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n    # Step 2: Invoke LLM callback\n    try:\n        agent_response = llm_callback(user_input, retrieved_memories)\n        if not isinstance(agent_response, str):\n            raise ValueError(\"LLM callback must return a string response\")\n        logger.info(\"LLM callback generated response\")\n    except Exception as e:\n        logger.error(\"LLM callback failed: %s\", e)\n        raise\n\n    # Step 3: Save the conversation turn\n    event = self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n        event_timestamp=event_timestamp,\n    )\n\n    logger.info(\"Completed full conversation turn with LLM\")\n    return retrieved_memories, agent_response, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories","title":"<code>retrieve_memories(memory_id, namespace, query, actor_id=None, top_k=3)</code>","text":"<p>Retrieve relevant memories from a namespace.</p> <p>Note: Wildcards (*) are NOT supported in namespaces. You must provide the exact namespace path with all variables resolved.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace path (no wildcards)</p> required <code>query</code> <code>str</code> <p>Search query</p> required <code>actor_id</code> <code>Optional[str]</code> <p>Optional actor ID (deprecated, use namespace)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of results to return</p> <code>3</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory records</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def retrieve_memories(\n    self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Retrieve relevant memories from a namespace.\n\n    Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n    exact namespace path with all variables resolved.\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace path (no wildcards)\n        query: Search query\n        actor_id: Optional actor ID (deprecated, use namespace)\n        top_k: Number of results to return\n\n    Returns:\n        List of memory records\n\n    Example:\n        # Correct - exact namespace\n        memories = client.retrieve_memories(\n            memory_id=\"mem-123\",\n            namespace=\"support/facts/session-456\",\n            query=\"customer preferences\"\n        )\n\n        # Incorrect - wildcards not supported\n        # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return []\n\n    try:\n        # Let service handle all namespace validation\n        response = self.gmdp_client.retrieve_memory_records(\n            memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n        )\n\n        memories = response.get(\"memoryRecordSummaries\", [])\n        logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n        return memories\n\n    except ClientError as e:\n        error_code = e.response[\"Error\"][\"Code\"]\n        error_msg = e.response[\"Error\"][\"Message\"]\n\n        if error_code == \"ResourceNotFoundException\":\n            logger.warning(\n                \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                memory_id,\n                namespace,\n            )\n        elif error_code == \"ValidationException\":\n            logger.warning(\"Invalid search parameters: %s\", error_msg)\n        elif error_code == \"ServiceException\":\n            logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n        else:\n            logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n        return []\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--correct-exact-namespace","title":"Correct - exact namespace","text":"<p>memories = client.retrieve_memories(     memory_id=\"mem-123\",     namespace=\"support/facts/session-456\",     query=\"customer preferences\" )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--incorrect-wildcards-not-supported","title":"Incorrect - wildcards not supported","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--memories-clientretrieve_memories-namespacesupportfacts","title":"memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation","title":"<code>save_conversation(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>DEPRECATED: Use create_event() instead.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use create_event() instead.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: Optional timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n    Returns:\n        Created event\n\n    Example:\n        # Save multi-turn conversation\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"And tomorrow?\", \"USER\"),\n                (\"Checking weather...\", \"TOOL\"),\n                (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n            ]\n        )\n\n        # Continue existing branch (only name required)\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[(\"Continue conversation\", \"USER\")],\n            branch={\"name\": \"existing-branch\"}\n        )\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        # Build payload\n        payload = []\n\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            # Validate role\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--save-multi-turn-conversation","title":"Save multi-turn conversation","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"And tomorrow?\", \"USER\"),         (\"Checking weather...\", \"TOOL\"),         (\"Today sunny, tomorrow rain\", \"ASSISTANT\")     ] )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--continue-existing-branch-only-name-required","title":"Continue existing branch (only name required)","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[(\"Continue conversation\", \"USER\")],     branch={\"name\": \"existing-branch\"} )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_turn","title":"<code>save_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None)</code>","text":"<p>DEPRECATED: Use save_conversation() for more flexibility.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"save_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use save_conversation() for flexible message handling.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n    return self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=messages,\n        event_timestamp=event_timestamp,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies","title":"<code>update_memory_strategies(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None)</code>","text":"<p>Update memory strategies - add, modify, or delete.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n    try:\n        memory_strategies = {}\n\n        if add_strategies:\n            processed_add = self._add_default_namespaces(add_strategies)\n            memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n        if modify_strategies:\n            current_strategies = self.get_memory_strategies(memory_id)\n            strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n            modify_list = []\n            for strategy in modify_strategies:\n                if \"memoryStrategyId\" not in strategy:  # Using old field name\n                    raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                strategy_info = strategy_map.get(strategy_id)\n\n                if not strategy_info:\n                    raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                strategy_copy = copy.deepcopy(strategy)\n\n                if \"configuration\" in strategy_copy:\n                    wrapped_config = self._wrap_configuration(\n                        strategy_copy[\"configuration\"], strategy_type, override_type\n                    )\n                    strategy_copy[\"configuration\"] = wrapped_config\n\n                modify_list.append(strategy_copy)\n\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n        if delete_strategy_ids:\n            delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n            memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n        if not memory_strategies:\n            raise ValueError(\"No strategy operations provided\")\n\n        response = self.gmcp_client.update_memory(\n            memoryId=memory_id,\n            memoryStrategies=memory_strategies,\n            clientToken=str(uuid.uuid4()),  # Using old field names for input\n        )\n\n        logger.info(\"Updated memory strategies for: %s\", memory_id)\n        memory = self._normalize_memory_response(response[\"memory\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies_and_wait","title":"<code>update_memory_strategies_and_wait(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, max_wait=300, poll_interval=10)</code>","text":"<p>Update memory strategies and wait for memory to return to ACTIVE state.</p> <p>This method handles the temporary CREATING state that occurs when updating strategies, preventing subsequent update errors.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies_and_wait(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n    This method handles the temporary CREATING state that occurs when\n    updating strategies, preventing subsequent update errors.\n    \"\"\"\n    # Update strategies\n    self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.wait_for_memories","title":"<code>wait_for_memories(memory_id, namespace, test_query='test', max_wait=180, poll_interval=15)</code>","text":"<p>Wait for memory extraction to complete by polling.</p> <p>IMPORTANT LIMITATIONS: 1. This method only works reliably on empty namespaces. If there are already    existing memories in the namespace, this method may return True immediately    even if new extractions haven't completed. 2. Wildcards () are NOT supported in namespaces. You must provide the exact    namespace path with all variables resolved (e.g., \"support/facts/session-123\"    not \"support/facts/\").</p> <p>For subsequent extractions in populated namespaces, use a fixed wait time:     time.sleep(150)  # Wait 2.5 minutes for extraction</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace to check (no wildcards)</p> required <code>test_query</code> <code>str</code> <p>Query to test with (default: \"test\")</p> <code>'test'</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 180)</p> <code>180</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 15)</p> <code>15</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if memories found, False if timeout</p> Note <p>This method will be deprecated in future versions once the API provides extraction status or timestamps.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def wait_for_memories(\n    self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n) -&gt; bool:\n    \"\"\"Wait for memory extraction to complete by polling.\n\n    IMPORTANT LIMITATIONS:\n    1. This method only works reliably on empty namespaces. If there are already\n       existing memories in the namespace, this method may return True immediately\n       even if new extractions haven't completed.\n    2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n       namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n       not \"support/facts/*\").\n\n    For subsequent extractions in populated namespaces, use a fixed wait time:\n        time.sleep(150)  # Wait 2.5 minutes for extraction\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace to check (no wildcards)\n        test_query: Query to test with (default: \"test\")\n        max_wait: Maximum seconds to wait (default: 180)\n        poll_interval: Seconds between checks (default: 15)\n\n    Returns:\n        True if memories found, False if timeout\n\n    Note:\n        This method will be deprecated in future versions once the API\n        provides extraction status or timestamps.\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return False\n\n    logger.warning(\n        \"wait_for_memories() only works reliably on empty namespaces. \"\n        \"For populated namespaces, consider using a fixed wait time instead.\"\n    )\n\n    logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n    start_time = time.time()\n    service_errors = 0\n\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n            if memories:\n                logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                return True\n\n            # Reset service error count on successful call\n            service_errors = 0\n\n        except Exception as e:\n            if \"ServiceException\" in str(e):\n                service_errors += 1\n                if service_errors &gt;= 3:\n                    logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n            logger.debug(\"Retrieval attempt failed: %s\", e)\n\n        if time.time() - start_time &lt; max_wait:\n            time.sleep(poll_interval)\n\n    logger.warning(\"No memories found after %d seconds\", max_wait)\n    if service_errors &gt; 0:\n        logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n    return False\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient","title":"<code>MemoryControlPlaneClient</code>","text":"<p>Client for Bedrock AgentCore Memory control plane operations.</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>class MemoryControlPlaneClient:\n    \"\"\"Client for Bedrock AgentCore Memory control plane operations.\"\"\"\n\n    def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n        \"\"\"Initialize the Memory Control Plane client.\n\n        Args:\n            region_name: AWS region name\n            environment: Environment name (prod, gamma, etc.)\n        \"\"\"\n        self.region_name = region_name\n        self.environment = environment\n\n        self.endpoint = os.getenv(\n            \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n        )\n\n        service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n        self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n        logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n\n    # ==================== MEMORY OPERATIONS ====================\n\n    def create_memory(\n        self,\n        name: str,\n        event_expiry_days: int = 90,\n        description: Optional[str] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory resource with optional strategies.\n\n        Args:\n            name: Name for the memory resource\n            event_expiry_days: How long to retain events (default: 90 days)\n            description: Optional description\n            memory_execution_role_arn: IAM role ARN for memory execution\n            strategies: Optional list of strategy configurations\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Created memory object\n        \"\"\"\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        if strategies:\n            params[\"memoryStrategies\"] = strategies\n\n        try:\n            response = self.client.create_memory(**params)\n            memory = response[\"memory\"]\n            memory_id = memory[\"id\"]\n\n            logger.info(\"Created memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"Get a memory resource by ID.\n\n        Args:\n            memory_id: Memory resource ID\n            include_strategies: Whether to include strategy details in response\n\n        Returns:\n            Memory resource details\n        \"\"\"\n        try:\n            response = self.client.get_memory(memoryId=memory_id)\n            memory = response[\"memory\"]\n\n            # Add strategy count\n            strategies = memory.get(\"strategies\", [])\n            memory[\"strategyCount\"] = len(strategies)\n\n            # Remove strategies if not requested\n            if not include_strategies and \"strategies\" in memory:\n                del memory[\"strategies\"]\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to get memory: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account with pagination support.\n\n        Args:\n            max_results: Maximum number of memories to return\n\n        Returns:\n            List of memory summaries\n        \"\"\"\n        try:\n            memories = []\n            next_token = None\n\n            while len(memories) &lt; max_results:\n                params = {\"maxResults\": min(100, max_results - len(memories))}\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.client.list_memories(**params)\n                batch = response.get(\"memories\", [])\n                memories.extend(batch)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(memories) &gt;= max_results:\n                    break\n\n            # Add strategy count to each memory summary\n            for memory in memories:\n                memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n            return memories[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def update_memory(\n        self,\n        memory_id: str,\n        description: Optional[str] = None,\n        event_expiry_days: Optional[int] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a memory resource properties and/or strategies.\n\n        Args:\n            memory_id: Memory resource ID\n            description: Optional new description\n            event_expiry_days: Optional new event expiry duration\n            memory_execution_role_arn: Optional new execution role ARN\n            add_strategies: Optional list of strategies to add\n            modify_strategies: Optional list of strategies to modify\n            delete_strategy_ids: Optional list of strategy IDs to delete\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        params: Dict = {\n            \"memoryId\": memory_id,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        # Add memory properties if provided\n        if description is not None:\n            params[\"description\"] = description\n\n        if event_expiry_days is not None:\n            params[\"eventExpiryDuration\"] = event_expiry_days\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        # Add strategy operations if provided\n        memory_strategies = {}\n\n        if add_strategies:\n            memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n        if modify_strategies:\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n        if delete_strategy_ids:\n            memory_strategies[\"deleteMemoryStrategies\"] = [\n                {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n            ]\n\n        if memory_strategies:\n            params[\"memoryStrategies\"] = memory_strategies\n\n        try:\n            response = self.client.update_memory(**params)\n            memory = response[\"memory\"]\n            logger.info(\"Updated memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory: %s\", e)\n            raise\n\n    def delete_memory(\n        self,\n        memory_id: str,\n        wait_for_deletion: bool = False,\n        wait_for_strategies: bool = False,  # Changed default to False\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            wait_for_deletion: Whether to wait for complete deletion\n            wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n            max_wait: Maximum seconds to wait if wait_for_deletion is True\n            poll_interval: Seconds between checks if wait_for_deletion is True\n\n        Returns:\n            Deletion response\n        \"\"\"\n        try:\n            # If requested, wait for all strategies to become ACTIVE before deletion\n            if wait_for_strategies:\n                try:\n                    memory = self.get_memory(memory_id)\n                    strategies = memory.get(\"strategies\", [])\n\n                    # Check if any strategies are in a transitional state\n                    transitional_strategies = [\n                        s\n                        for s in strategies\n                        if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                    ]\n\n                    if transitional_strategies:\n                        logger.info(\n                            \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                        )\n                        self._wait_for_status(\n                            memory_id=memory_id,\n                            target_status=MemoryStatus.ACTIVE.value,\n                            max_wait=max_wait,\n                            poll_interval=poll_interval,\n                            check_strategies=True,\n                        )\n                except Exception as e:\n                    logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n            # Now delete the memory\n            response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n            logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n            if not wait_for_deletion:\n                return response\n\n            # Wait for deletion to complete\n            start_time = time.time()\n            while time.time() - start_time &lt; max_wait:\n                try:\n                    self.client.get_memory(memoryId=memory_id)\n                    time.sleep(poll_interval)\n                except ClientError as e:\n                    if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                        logger.info(\"Memory %s successfully deleted\", memory_id)\n                        return response\n                    raise\n\n            raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    # ==================== STRATEGY OPERATIONS ====================\n\n    def add_strategy(\n        self,\n        memory_id: str,\n        strategy: Dict[str, Any],\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object with strategyId field\n        \"\"\"\n        # Get the strategy type and name for identification\n        strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n        strategy_name = strategy[strategy_type].get(\"name\")\n\n        logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n        # Use update_memory with add_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            add_strategies=[strategy],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            # First, get the memory again to ensure we have the latest state\n            memory = self.get_memory(memory_id)\n\n            # Find the newly added strategy by matching name\n            strategies = memory.get(\"strategies\", [])\n            strategy_id = None\n\n            for s in strategies:\n                # Match by name since that's unique within a memory\n                if s.get(\"name\") == strategy_name:\n                    strategy_id = s.get(\"strategyId\")\n                    logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                    break\n\n            if strategy_id:\n                return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n            else:\n                logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n        return memory\n\n    def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a specific strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID\n\n        Returns:\n            Strategy details\n        \"\"\"\n        try:\n            memory = self.get_memory(memory_id)\n            strategies = memory.get(\"strategies\", [])\n\n            for strategy in strategies:\n                if strategy.get(\"strategyId\") == strategy_id:\n                    return strategy\n\n            raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n        except ClientError as e:\n            logger.error(\"Failed to get strategy: %s\", e)\n            raise\n\n    def update_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a strategy in a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to update\n            description: Optional new description\n            namespaces: Optional new namespaces list\n            configuration: Optional new configuration\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # Note: API expects memoryStrategyId for input but returns strategyId in response\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n        if description is not None:\n            modify_config[\"description\"] = description\n\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        # Use update_memory with modify_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            modify_strategies=[modify_config],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n        return memory\n\n    def remove_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Remove a strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to remove\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # For remove_strategy, we only need to wait for memory to be active\n        # since the strategy will be gone\n        return self.update_memory(\n            memory_id=memory_id,\n            delete_strategy_ids=[strategy_id],\n            wait_for_active=wait_for_active,\n            max_wait=max_wait,\n            poll_interval=poll_interval,\n        )\n\n    # ==================== HELPER METHODS ====================\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state.\"\"\"\n        logger.info(\"Waiting for memory %s to become ACTIVE...\", memory_id)\n        return self._wait_for_status(\n            memory_id=memory_id, target_status=MemoryStatus.ACTIVE.value, max_wait=max_wait, poll_interval=poll_interval\n        )\n\n    def _wait_for_strategy_active(\n        self, memory_id: str, strategy_id: str, max_wait: int, poll_interval: int\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wait for specific memory strategy to become ACTIVE.\"\"\"\n        logger.info(\"Waiting for strategy %s to become ACTIVE (max wait: %d seconds)...\", strategy_id, max_wait)\n\n        start_time = time.time()\n        last_status = None\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                for strategy in strategies:\n                    if strategy.get(\"strategyId\") == strategy_id:\n                        status = strategy[\"status\"]\n\n                        # Log status changes\n                        if status != last_status:\n                            logger.info(\"Strategy %s status: %s\", strategy_id, status)\n                            last_status = status\n\n                        if status == MemoryStatus.ACTIVE.value:\n                            elapsed = time.time() - start_time\n                            logger.info(\"Strategy %s is now ACTIVE (took %.1f seconds)\", strategy_id, elapsed)\n                            return memory\n                        elif status == MemoryStatus.FAILED.value:\n                            failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                            raise RuntimeError(f\"Strategy {strategy_id} failed to activate: {failure_reason}\")\n\n                        break\n                else:\n                    logger.warning(\"Strategy %s not found in memory %s\", strategy_id, memory_id)\n\n                # Wait before checking again\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking strategy status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Strategy {strategy_id} did not become ACTIVE within {max_wait} seconds (last status: {last_status})\"\n        )\n\n    def _wait_for_status(\n        self, memory_id: str, target_status: str, max_wait: int, poll_interval: int, check_strategies: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generic method to wait for a memory to reach a specific status.\n\n        Args:\n            memory_id: The ID of the memory to check\n            target_status: The status to wait for (e.g., \"ACTIVE\")\n            max_wait: Maximum time to wait in seconds\n            poll_interval: Time between status checks in seconds\n            check_strategies: Whether to also check that all strategies are in the target status\n\n        Returns:\n            The memory object once it reaches the target status\n\n        Raises:\n            TimeoutError: If the memory doesn't reach the target status within max_wait\n            RuntimeError: If the memory or any strategy reaches a FAILED state\n        \"\"\"\n        logger.info(\"Waiting for memory %s to reach status %s...\", memory_id, target_status)\n\n        start_time = time.time()\n        last_memory_status = None\n        strategy_statuses = {}\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                status = memory.get(\"status\")\n\n                # Log status changes for memory\n                if status != last_memory_status:\n                    logger.info(\"Memory %s status: %s\", memory_id, status)\n                    last_memory_status = status\n\n                if status == target_status:\n                    # Check if all strategies are also in the target status\n                    if check_strategies and target_status == MemoryStatus.ACTIVE.value:\n                        strategies = memory.get(\"strategies\", [])\n                        all_strategies_active = True\n\n                        for strategy in strategies:\n                            strategy_id = strategy.get(\"strategyId\")\n                            strategy_status = strategy.get(\"status\")\n\n                            # Log strategy status changes\n                            if (\n                                strategy_id not in strategy_statuses\n                                or strategy_statuses[strategy_id] != strategy_status\n                            ):\n                                logger.info(\"Strategy %s status: %s\", strategy_id, strategy_status)\n                                strategy_statuses[strategy_id] = strategy_status\n\n                            if strategy_status != target_status:\n                                if strategy_status == MemoryStatus.FAILED.value:\n                                    failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                                    raise RuntimeError(f\"Strategy {strategy_id} failed: {failure_reason}\")\n\n                                all_strategies_active = False\n\n                        if not all_strategies_active:\n                            logger.info(\n                                \"Memory %s is %s but %d strategies are still processing\",\n                                memory_id,\n                                target_status,\n                                len([s for s in strategies if s.get(\"status\") != target_status]),\n                            )\n                            time.sleep(poll_interval)\n                            continue\n\n                    elapsed = time.time() - start_time\n                    logger.info(\n                        \"Memory %s and all strategies are now %s (took %.1f seconds)\", memory_id, target_status, elapsed\n                    )\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    failure_reason = memory.get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(f\"Memory operation failed: {failure_reason}\")\n\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Memory {memory_id} did not reach status {target_status} within {max_wait} seconds \"\n            f\"(elapsed: {elapsed:.1f}s)\"\n        )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.__init__","title":"<code>__init__(region_name='us-west-2', environment='prod')</code>","text":"<p>Initialize the Memory Control Plane client.</p> <p>Parameters:</p> Name Type Description Default <code>region_name</code> <code>str</code> <p>AWS region name</p> <code>'us-west-2'</code> <code>environment</code> <code>str</code> <p>Environment name (prod, gamma, etc.)</p> <code>'prod'</code> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n    \"\"\"Initialize the Memory Control Plane client.\n\n    Args:\n        region_name: AWS region name\n        environment: Environment name (prod, gamma, etc.)\n    \"\"\"\n    self.region_name = region_name\n    self.environment = environment\n\n    self.endpoint = os.getenv(\n        \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n    )\n\n    service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n    self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n    logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.add_strategy","title":"<code>add_strategy(memory_id, strategy, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Add a strategy to a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object with strategyId field</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def add_strategy(\n    self,\n    memory_id: str,\n    strategy: Dict[str, Any],\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object with strategyId field\n    \"\"\"\n    # Get the strategy type and name for identification\n    strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n    strategy_name = strategy[strategy_type].get(\"name\")\n\n    logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n    # Use update_memory with add_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        add_strategies=[strategy],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        # First, get the memory again to ensure we have the latest state\n        memory = self.get_memory(memory_id)\n\n        # Find the newly added strategy by matching name\n        strategies = memory.get(\"strategies\", [])\n        strategy_id = None\n\n        for s in strategies:\n            # Match by name since that's unique within a memory\n            if s.get(\"name\") == strategy_name:\n                strategy_id = s.get(\"strategyId\")\n                logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                break\n\n        if strategy_id:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n        else:\n            logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n    return memory\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.create_memory","title":"<code>create_memory(name, event_expiry_days=90, description=None, memory_execution_role_arn=None, strategies=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory resource with optional strategies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategy configurations</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    event_expiry_days: int = 90,\n    description: Optional[str] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory resource with optional strategies.\n\n    Args:\n        name: Name for the memory resource\n        event_expiry_days: How long to retain events (default: 90 days)\n        description: Optional description\n        memory_execution_role_arn: IAM role ARN for memory execution\n        strategies: Optional list of strategy configurations\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Created memory object\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"eventExpiryDuration\": event_expiry_days,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    if description:\n        params[\"description\"] = description\n\n    if memory_execution_role_arn:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    if strategies:\n        params[\"memoryStrategies\"] = strategies\n\n    try:\n        response = self.client.create_memory(**params)\n        memory = response[\"memory\"]\n        memory_id = memory[\"id\"]\n\n        logger.info(\"Created memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.delete_memory","title":"<code>delete_memory(memory_id, wait_for_deletion=False, wait_for_strategies=False, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for complete deletion</p> <code>False</code> <code>wait_for_strategies</code> <code>bool</code> <p>Whether to wait for strategies to become ACTIVE before deletion</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_deletion is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks if wait_for_deletion is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Deletion response</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def delete_memory(\n    self,\n    memory_id: str,\n    wait_for_deletion: bool = False,\n    wait_for_strategies: bool = False,  # Changed default to False\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        wait_for_deletion: Whether to wait for complete deletion\n        wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n        max_wait: Maximum seconds to wait if wait_for_deletion is True\n        poll_interval: Seconds between checks if wait_for_deletion is True\n\n    Returns:\n        Deletion response\n    \"\"\"\n    try:\n        # If requested, wait for all strategies to become ACTIVE before deletion\n        if wait_for_strategies:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                # Check if any strategies are in a transitional state\n                transitional_strategies = [\n                    s\n                    for s in strategies\n                    if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                ]\n\n                if transitional_strategies:\n                    logger.info(\n                        \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                    )\n                    self._wait_for_status(\n                        memory_id=memory_id,\n                        target_status=MemoryStatus.ACTIVE.value,\n                        max_wait=max_wait,\n                        poll_interval=poll_interval,\n                        check_strategies=True,\n                    )\n            except Exception as e:\n                logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n        # Now delete the memory\n        response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n        logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n        if not wait_for_deletion:\n            return response\n\n        # Wait for deletion to complete\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            try:\n                self.client.get_memory(memoryId=memory_id)\n                time.sleep(poll_interval)\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted\", memory_id)\n                    return response\n                raise\n\n        raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_memory","title":"<code>get_memory(memory_id, include_strategies=True)</code>","text":"<p>Get a memory resource by ID.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>include_strategies</code> <code>bool</code> <p>Whether to include strategy details in response</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Memory resource details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"Get a memory resource by ID.\n\n    Args:\n        memory_id: Memory resource ID\n        include_strategies: Whether to include strategy details in response\n\n    Returns:\n        Memory resource details\n    \"\"\"\n    try:\n        response = self.client.get_memory(memoryId=memory_id)\n        memory = response[\"memory\"]\n\n        # Add strategy count\n        strategies = memory.get(\"strategies\", [])\n        memory[\"strategyCount\"] = len(strategies)\n\n        # Remove strategies if not requested\n        if not include_strategies and \"strategies\" in memory:\n            del memory[\"strategies\"]\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to get memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_strategy","title":"<code>get_strategy(memory_id, strategy_id)</code>","text":"<p>Get a specific strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Strategy details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a specific strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID\n\n    Returns:\n        Strategy details\n    \"\"\"\n    try:\n        memory = self.get_memory(memory_id)\n        strategies = memory.get(\"strategies\", [])\n\n        for strategy in strategies:\n            if strategy.get(\"strategyId\") == strategy_id:\n                return strategy\n\n        raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n    except ClientError as e:\n        logger.error(\"Failed to get strategy: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account with pagination support.</p> <p>Parameters:</p> Name Type Description Default <code>max_results</code> <code>int</code> <p>Maximum number of memories to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory summaries</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account with pagination support.\n\n    Args:\n        max_results: Maximum number of memories to return\n\n    Returns:\n        List of memory summaries\n    \"\"\"\n    try:\n        memories = []\n        next_token = None\n\n        while len(memories) &lt; max_results:\n            params = {\"maxResults\": min(100, max_results - len(memories))}\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.client.list_memories(**params)\n            batch = response.get(\"memories\", [])\n            memories.extend(batch)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(memories) &gt;= max_results:\n                break\n\n        # Add strategy count to each memory summary\n        for memory in memories:\n            memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n        return memories[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.remove_strategy","title":"<code>remove_strategy(memory_id, strategy_id, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Remove a strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to remove</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def remove_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Remove a strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to remove\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # For remove_strategy, we only need to wait for memory to be active\n    # since the strategy will be gone\n    return self.update_memory(\n        memory_id=memory_id,\n        delete_strategy_ids=[strategy_id],\n        wait_for_active=wait_for_active,\n        max_wait=max_wait,\n        poll_interval=poll_interval,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_memory","title":"<code>update_memory(memory_id, description=None, event_expiry_days=None, memory_execution_role_arn=None, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a memory resource properties and/or strategies.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>event_expiry_days</code> <code>Optional[int]</code> <p>Optional new event expiry duration</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>Optional new execution role ARN</p> <code>None</code> <code>add_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to add</p> <code>None</code> <code>modify_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to modify</p> <code>None</code> <code>delete_strategy_ids</code> <code>Optional[List[str]]</code> <p>Optional list of strategy IDs to delete</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_memory(\n    self,\n    memory_id: str,\n    description: Optional[str] = None,\n    event_expiry_days: Optional[int] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a memory resource properties and/or strategies.\n\n    Args:\n        memory_id: Memory resource ID\n        description: Optional new description\n        event_expiry_days: Optional new event expiry duration\n        memory_execution_role_arn: Optional new execution role ARN\n        add_strategies: Optional list of strategies to add\n        modify_strategies: Optional list of strategies to modify\n        delete_strategy_ids: Optional list of strategy IDs to delete\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    params: Dict = {\n        \"memoryId\": memory_id,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    # Add memory properties if provided\n    if description is not None:\n        params[\"description\"] = description\n\n    if event_expiry_days is not None:\n        params[\"eventExpiryDuration\"] = event_expiry_days\n\n    if memory_execution_role_arn is not None:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    # Add strategy operations if provided\n    memory_strategies = {}\n\n    if add_strategies:\n        memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n    if modify_strategies:\n        memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n    if delete_strategy_ids:\n        memory_strategies[\"deleteMemoryStrategies\"] = [\n            {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n        ]\n\n    if memory_strategies:\n        params[\"memoryStrategies\"] = memory_strategies\n\n    try:\n        response = self.client.update_memory(**params)\n        memory = response[\"memory\"]\n        logger.info(\"Updated memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_strategy","title":"<code>update_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a strategy in a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to update</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional new namespaces list</p> <code>None</code> <code>configuration</code> <code>Optional[Dict[str, Any]]</code> <p>Optional new configuration</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a strategy in a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to update\n        description: Optional new description\n        namespaces: Optional new namespaces list\n        configuration: Optional new configuration\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # Note: API expects memoryStrategyId for input but returns strategyId in response\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n    if description is not None:\n        modify_config[\"description\"] = description\n\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    # Use update_memory with modify_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        modify_strategies=[modify_config],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n    return memory\n</code></pre>"},{"location":"api-reference/runtime.html","title":"Runtime","text":"<p>Runtime management and application context for Bedrock AgentCore.</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime","title":"<code>bedrock_agentcore.runtime</code>","text":"<p>BedrockAgentCore Runtime Package.</p> <p>This package contains the core runtime components for Bedrock AgentCore applications: - BedrockAgentCoreApp: Main application class - RequestContext: HTTP request context - BedrockAgentCoreContext: Agent identity context</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp","title":"<code>BedrockAgentCoreApp</code>","text":"<p>               Bases: <code>Starlette</code></p> <p>Bedrock AgentCore application class that extends Starlette for AI agent deployment.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>class BedrockAgentCoreApp(Starlette):\n    \"\"\"Bedrock AgentCore application class that extends Starlette for AI agent deployment.\"\"\"\n\n    def __init__(self, debug: bool = False):\n        \"\"\"Initialize Bedrock AgentCore application.\n\n        Args:\n            debug: Enable debug actions for task management (default: False)\n        \"\"\"\n        self.handlers: Dict[str, Callable] = {}\n        self._ping_handler: Optional[Callable] = None\n        self._active_tasks: Dict[int, Dict[str, Any]] = {}\n        self._task_counter_lock: threading.Lock = threading.Lock()\n        self._forced_ping_status: Optional[PingStatus] = None\n        self._last_status_update_time: float = time.time()\n        self._invocation_executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix=\"invocation\")\n        self._invocation_semaphore = asyncio.Semaphore(2)\n\n        routes = [\n            Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n            Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n        ]\n        super().__init__(routes=routes)\n        self.debug = debug  # Set after super().__init__ to avoid override\n\n        self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n        if not self.logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = RequestContextFormatter(\"%(asctime)s - %(name)s - %(levelname)s - %(request_id)s%(message)s\")\n            handler.setFormatter(formatter)\n            self.logger.addHandler(handler)\n            self.logger.setLevel(logging.INFO)\n\n    def entrypoint(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a function as the main entrypoint.\n\n        Args:\n            func: The function to register as entrypoint\n\n        Returns:\n            The decorated function with added serve method\n        \"\"\"\n        self.handlers[\"main\"] = func\n        func.run = lambda port=8080, host=None: self.run(port, host)\n        return func\n\n    def ping(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a custom ping status handler.\n\n        Args:\n            func: The function to register as ping status handler\n\n        Returns:\n            The decorated function\n        \"\"\"\n        self._ping_handler = func\n        return func\n\n    def async_task(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to track async tasks for ping status.\n\n        When a function is decorated with @async_task, it will:\n        - Set ping status to HEALTHY_BUSY while running\n        - Revert to HEALTHY when complete\n        \"\"\"\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"@async_task can only be applied to async functions\")\n\n        async def wrapper(*args, **kwargs):\n            task_id = self.add_async_task(func.__name__)\n\n            try:\n                self.logger.debug(\"Starting async task: %s\", func.__name__)\n                start_time = time.time()\n                result = await func(*args, **kwargs)\n                duration = time.time() - start_time\n                self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n                return result\n            except Exception as e:\n                duration = time.time() - start_time\n                self.logger.error(\n                    \"Async task failed: %s (%.3fs) - %s: %s\", func.__name__, duration, type(e).__name__, e\n                )\n                raise\n            finally:\n                self.complete_async_task(task_id)\n\n        wrapper.__name__ = func.__name__\n        return wrapper\n\n    def get_current_ping_status(self) -&gt; PingStatus:\n        \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n        current_status = None\n\n        if self._forced_ping_status is not None:\n            current_status = self._forced_ping_status\n        elif self._ping_handler:\n            try:\n                result = self._ping_handler()\n                if isinstance(result, str):\n                    current_status = PingStatus(result)\n                else:\n                    current_status = result\n            except Exception as e:\n                self.logger.warning(\n                    \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n                )\n\n        if current_status is None:\n            current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n        if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n            self._last_known_status = current_status\n            self._last_status_update_time = time.time()\n\n        return current_status\n\n    def force_ping_status(self, status: PingStatus):\n        \"\"\"Force ping status to a specific value.\"\"\"\n        self._forced_ping_status = status\n\n    def clear_forced_ping_status(self):\n        \"\"\"Clear forced status and resume automatic.\"\"\"\n        self._forced_ping_status = None\n\n    def get_async_task_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get info about running async tasks.\"\"\"\n        running_jobs = []\n        for t in self._active_tasks.values():\n            try:\n                running_jobs.append(\n                    {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n                )\n            except Exception as e:\n                self.logger.warning(\"Caught exception, continuing...: %s\", e)\n                continue\n\n        return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n\n    def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n        \"\"\"Register an async task for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively start tracking tasks for health monitoring.\n        Use this when you need precise control over when tasks begin and end.\n\n        Args:\n            name: Human-readable task name for monitoring\n            metadata: Optional additional task metadata\n\n        Returns:\n            Task ID for tracking and completion\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n            # ... do background work ...\n            app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n            # Register task start with same structure as @async_task decorator\n            task_info = {\"name\": name, \"start_time\": time.time()}\n            if metadata:\n                task_info[\"metadata\"] = metadata\n\n            self._active_tasks[task_id] = task_info\n\n        self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n        return task_id\n\n    def complete_async_task(self, task_id: int) -&gt; bool:\n        \"\"\"Mark an async task as complete for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively complete tasks for health monitoring.\n        Call this when your background work finishes.\n\n        Args:\n            task_id: Task ID returned from add_async_task\n\n        Returns:\n            True if task was found and completed, False otherwise\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\")\n            # ... do background work ...\n            completed = app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_info = self._active_tasks.pop(task_id, None)\n            if task_info:\n                task_name = task_info.get(\"name\", \"unknown\")\n                duration = time.time() - task_info.get(\"start_time\", time.time())\n\n                self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n                return True\n            else:\n                self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n                return False\n\n    def _build_request_context(self, request) -&gt; RequestContext:\n        \"\"\"Build request context and setup auth if present.\"\"\"\n        try:\n            agent_identity_token = request.headers.get(ACCESS_TOKEN_HEADER) or request.headers.get(\n                ACCESS_TOKEN_HEADER.lower()\n            )\n            if agent_identity_token:\n                BedrockAgentCoreContext.set_workload_access_token(agent_identity_token)\n            session_id = request.headers.get(SESSION_HEADER) or request.headers.get(SESSION_HEADER.lower())\n            return RequestContext(session_id=session_id)\n        except Exception as e:\n            self.logger.warning(\"Failed to build request context: %s: %s\", type(e).__name__, e)\n            return RequestContext(session_id=None)\n\n    def _takes_context(self, handler: Callable) -&gt; bool:\n        try:\n            params = list(inspect.signature(handler).parameters.keys())\n            return len(params) &gt;= 2 and params[1] == \"context\"\n        except Exception:\n            return False\n\n    async def _handle_invocation(self, request):\n        request_id = str(uuid.uuid4())[:8]\n        request_id_context.set(request_id)\n        start_time = time.time()\n\n        try:\n            payload = await request.json()\n            self.logger.debug(\"Processing invocation request\")\n\n            if self.debug:\n                task_response = self._handle_task_action(payload)\n                if task_response:\n                    duration = time.time() - start_time\n                    self.logger.info(\"Debug action completed (%.3fs)\", duration)\n                    return task_response\n\n            handler = self.handlers.get(\"main\")\n            if not handler:\n                self.logger.error(\"No entrypoint defined\")\n                return JSONResponse({\"error\": \"No entrypoint defined\"}, status_code=500)\n\n            request_context = self._build_request_context(request)\n            takes_context = self._takes_context(handler)\n\n            handler_name = handler.__name__ if hasattr(handler, \"__name__\") else \"unknown\"\n            self.logger.debug(\"Invoking handler: %s\", handler_name)\n            result = await self._invoke_handler(handler, request_context, takes_context, payload)\n\n            duration = time.time() - start_time\n            if inspect.isgenerator(result):\n                self.logger.info(\"Returning streaming response (generator) (%.3fs)\", duration)\n                return StreamingResponse(self._sync_stream_with_error_handling(result), media_type=\"text/event-stream\")\n            elif inspect.isasyncgen(result):\n                self.logger.info(\"Returning streaming response (async generator) (%.3fs)\", duration)\n                return StreamingResponse(self._stream_with_error_handling(result), media_type=\"text/event-stream\")\n\n            self.logger.info(\"Invocation completed successfully (%.3fs)\", duration)\n            # Use safe serialization for consistency with streaming paths\n            safe_json_string = self._safe_serialize_to_json_string(result)\n            return Response(safe_json_string, media_type=\"application/json\")\n\n        except json.JSONDecodeError as e:\n            duration = time.time() - start_time\n            self.logger.warning(\"Invalid JSON in request (%.3fs): %s\", duration, e)\n            return JSONResponse({\"error\": \"Invalid JSON\", \"details\": str(e)}, status_code=400)\n        except Exception as e:\n            duration = time.time() - start_time\n            self.logger.exception(\"Invocation failed (%.3fs)\", duration)\n            return JSONResponse({\"error\": str(e)}, status_code=500)\n\n    def _handle_ping(self, request):\n        try:\n            status = self.get_current_ping_status()\n            self.logger.debug(\"Ping request - status: %s\", status.value)\n            return JSONResponse({\"status\": status.value, \"time_of_last_update\": int(self._last_status_update_time)})\n        except Exception as e:\n            self.logger.error(\"Ping endpoint failed: %s: %s\", type(e).__name__, e)\n            return JSONResponse({\"status\": PingStatus.HEALTHY.value, \"time_of_last_update\": int(time.time())})\n\n    def run(self, port: int = 8080, host: Optional[str] = None):\n        \"\"\"Start the Bedrock AgentCore server.\n\n        Args:\n            port: Port to serve on, defaults to 8080\n            host: Host to bind to, auto-detected if None\n        \"\"\"\n        import os\n\n        import uvicorn\n\n        if host is None:\n            if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n                host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n            else:\n                host = \"127.0.0.1\"\n        uvicorn.run(self, host=host, port=port)\n\n    async def _invoke_handler(self, handler, request_context, takes_context, payload):\n        if self._invocation_semaphore.locked():\n            return JSONResponse({\"error\": \"Server busy - maximum concurrent requests reached\"}, status_code=503)\n\n        async with self._invocation_semaphore:\n            try:\n                args = (payload, request_context) if takes_context else (payload,)\n                if asyncio.iscoroutinefunction(handler):\n                    return await handler(*args)\n                else:\n                    loop = asyncio.get_event_loop()\n                    return await loop.run_in_executor(self._invocation_executor, handler, *args)\n            except Exception as e:\n                handler_name = getattr(handler, \"__name__\", \"unknown\")\n                self.logger.error(\"Handler '%s' execution failed: %s: %s\", handler_name, type(e).__name__, e)\n                raise\n\n    def _handle_task_action(self, payload: dict) -&gt; Optional[JSONResponse]:\n        \"\"\"Handle task management actions if present in payload.\"\"\"\n        action = payload.get(\"_agent_core_app_action\")\n        if not action:\n            return None\n\n        self.logger.debug(\"Processing debug action: %s\", action)\n\n        try:\n            actions = {\n                TASK_ACTION_PING_STATUS: lambda: JSONResponse(\n                    {\n                        \"status\": self.get_current_ping_status().value,\n                        \"time_of_last_update\": int(self._last_status_update_time),\n                    }\n                ),\n                TASK_ACTION_JOB_STATUS: lambda: JSONResponse(self.get_async_task_info()),\n                TASK_ACTION_FORCE_HEALTHY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY),\n                    self.logger.info(\"Ping status forced to Healthy\"),\n                    JSONResponse({\"forced_status\": \"Healthy\"}),\n                )[2],\n                TASK_ACTION_FORCE_BUSY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY_BUSY),\n                    self.logger.info(\"Ping status forced to HealthyBusy\"),\n                    JSONResponse({\"forced_status\": \"HealthyBusy\"}),\n                )[2],\n                TASK_ACTION_CLEAR_FORCED_STATUS: lambda: (\n                    self.clear_forced_ping_status(),\n                    self.logger.info(\"Forced ping status cleared\"),\n                    JSONResponse({\"forced_status\": \"Cleared\"}),\n                )[2],\n            }\n\n            if action in actions:\n                response = actions[action]()\n                self.logger.debug(\"Debug action '%s' completed successfully\", action)\n                return response\n\n            self.logger.warning(\"Unknown debug action requested: %s\", action)\n            return JSONResponse({\"error\": f\"Unknown action: {action}\"}, status_code=400)\n\n        except Exception as e:\n            self.logger.error(\"Debug action '%s' failed: %s: %s\", action, type(e).__name__, e)\n            return JSONResponse({\"error\": \"Debug action failed\", \"details\": str(e)}, status_code=500)\n\n    async def _stream_with_error_handling(self, generator):\n        \"\"\"Wrap async generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            async for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.error(\"Error in async streaming: %s: %s\", type(e).__name__, e)\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n\n    def _safe_serialize_to_json_string(self, obj):\n        \"\"\"Safely serialize object directly to JSON string with progressive fallback handling.\n\n        This method eliminates double JSON encoding by returning the JSON string directly,\n        avoiding the test-then-encode pattern that leads to redundant json.dumps() calls.\n        Used by both streaming and non-streaming responses for consistent behavior.\n\n        Returns:\n            str: JSON string representation of the object\n        \"\"\"\n        try:\n            # First attempt: direct JSON serialization with Unicode support\n            return json.dumps(obj, ensure_ascii=False)\n        except (TypeError, ValueError, UnicodeEncodeError):\n            try:\n                # Second attempt: convert to string, then JSON encode the string\n                return json.dumps(str(obj), ensure_ascii=False)\n            except Exception as e:\n                # Final fallback: JSON encode error object with ASCII fallback for problematic Unicode\n                self.logger.warning(\"Failed to serialize object: %s: %s\", type(e).__name__, e)\n                error_obj = {\"error\": \"Serialization failed\", \"original_type\": type(obj).__name__}\n                return json.dumps(error_obj, ensure_ascii=False)\n\n    def _convert_to_sse(self, obj) -&gt; bytes:\n        \"\"\"Convert object to Server-Sent Events format using safe serialization.\n\n        Args:\n            obj: Object to convert to SSE format\n\n        Returns:\n            bytes: SSE-formatted data ready for streaming\n        \"\"\"\n        json_string = self._safe_serialize_to_json_string(obj)\n        sse_data = f\"data: {json_string}\\n\\n\"\n        return sse_data.encode(\"utf-8\")\n\n    def _sync_stream_with_error_handling(self, generator):\n        \"\"\"Wrap sync generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.error(\"Error in sync streaming: %s: %s\", type(e).__name__, e)\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>Initialize Bedrock AgentCore application.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Enable debug actions for task management (default: False)</p> <code>False</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def __init__(self, debug: bool = False):\n    \"\"\"Initialize Bedrock AgentCore application.\n\n    Args:\n        debug: Enable debug actions for task management (default: False)\n    \"\"\"\n    self.handlers: Dict[str, Callable] = {}\n    self._ping_handler: Optional[Callable] = None\n    self._active_tasks: Dict[int, Dict[str, Any]] = {}\n    self._task_counter_lock: threading.Lock = threading.Lock()\n    self._forced_ping_status: Optional[PingStatus] = None\n    self._last_status_update_time: float = time.time()\n    self._invocation_executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix=\"invocation\")\n    self._invocation_semaphore = asyncio.Semaphore(2)\n\n    routes = [\n        Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n        Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n    ]\n    super().__init__(routes=routes)\n    self.debug = debug  # Set after super().__init__ to avoid override\n\n    self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n    if not self.logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = RequestContextFormatter(\"%(asctime)s - %(name)s - %(levelname)s - %(request_id)s%(message)s\")\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task","title":"<code>add_async_task(name, metadata=None)</code>","text":"<p>Register an async task for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively start tracking tasks for health monitoring. Use this when you need precise control over when tasks begin and end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable task name for monitoring</p> required <code>metadata</code> <code>Optional[Dict]</code> <p>Optional additional task metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Task ID for tracking and completion</p> Example <p>task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n    \"\"\"Register an async task for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively start tracking tasks for health monitoring.\n    Use this when you need precise control over when tasks begin and end.\n\n    Args:\n        name: Human-readable task name for monitoring\n        metadata: Optional additional task metadata\n\n    Returns:\n        Task ID for tracking and completion\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n        # ... do background work ...\n        app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n        # Register task start with same structure as @async_task decorator\n        task_info = {\"name\": name, \"start_time\": time.time()}\n        if metadata:\n            task_info[\"metadata\"] = metadata\n\n        self._active_tasks[task_id] = task_info\n\n    self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n    return task_id\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task--do-background-work","title":"... do background work ...","text":"<p>app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.async_task","title":"<code>async_task(func)</code>","text":"<p>Decorator to track async tasks for ping status.</p> <p>When a function is decorated with @async_task, it will: - Set ping status to HEALTHY_BUSY while running - Revert to HEALTHY when complete</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def async_task(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to track async tasks for ping status.\n\n    When a function is decorated with @async_task, it will:\n    - Set ping status to HEALTHY_BUSY while running\n    - Revert to HEALTHY when complete\n    \"\"\"\n    if not asyncio.iscoroutinefunction(func):\n        raise ValueError(\"@async_task can only be applied to async functions\")\n\n    async def wrapper(*args, **kwargs):\n        task_id = self.add_async_task(func.__name__)\n\n        try:\n            self.logger.debug(\"Starting async task: %s\", func.__name__)\n            start_time = time.time()\n            result = await func(*args, **kwargs)\n            duration = time.time() - start_time\n            self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n            return result\n        except Exception as e:\n            duration = time.time() - start_time\n            self.logger.error(\n                \"Async task failed: %s (%.3fs) - %s: %s\", func.__name__, duration, type(e).__name__, e\n            )\n            raise\n        finally:\n            self.complete_async_task(task_id)\n\n    wrapper.__name__ = func.__name__\n    return wrapper\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.clear_forced_ping_status","title":"<code>clear_forced_ping_status()</code>","text":"<p>Clear forced status and resume automatic.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def clear_forced_ping_status(self):\n    \"\"\"Clear forced status and resume automatic.\"\"\"\n    self._forced_ping_status = None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task","title":"<code>complete_async_task(task_id)</code>","text":"<p>Mark an async task as complete for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively complete tasks for health monitoring. Call this when your background work finishes.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Task ID returned from add_async_task</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if task was found and completed, False otherwise</p> Example <p>task_id = app.add_async_task(\"file_processing\")</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def complete_async_task(self, task_id: int) -&gt; bool:\n    \"\"\"Mark an async task as complete for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively complete tasks for health monitoring.\n    Call this when your background work finishes.\n\n    Args:\n        task_id: Task ID returned from add_async_task\n\n    Returns:\n        True if task was found and completed, False otherwise\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\")\n        # ... do background work ...\n        completed = app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_info = self._active_tasks.pop(task_id, None)\n        if task_info:\n            task_name = task_info.get(\"name\", \"unknown\")\n            duration = time.time() - task_info.get(\"start_time\", time.time())\n\n            self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n            return True\n        else:\n            self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n            return False\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task--do-background-work","title":"... do background work ...","text":"<p>completed = app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.entrypoint","title":"<code>entrypoint(func)</code>","text":"<p>Decorator to register a function as the main entrypoint.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as entrypoint</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function with added serve method</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def entrypoint(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a function as the main entrypoint.\n\n    Args:\n        func: The function to register as entrypoint\n\n    Returns:\n        The decorated function with added serve method\n    \"\"\"\n    self.handlers[\"main\"] = func\n    func.run = lambda port=8080, host=None: self.run(port, host)\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.force_ping_status","title":"<code>force_ping_status(status)</code>","text":"<p>Force ping status to a specific value.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def force_ping_status(self, status: PingStatus):\n    \"\"\"Force ping status to a specific value.\"\"\"\n    self._forced_ping_status = status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_async_task_info","title":"<code>get_async_task_info()</code>","text":"<p>Get info about running async tasks.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_async_task_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get info about running async tasks.\"\"\"\n    running_jobs = []\n    for t in self._active_tasks.values():\n        try:\n            running_jobs.append(\n                {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n            )\n        except Exception as e:\n            self.logger.warning(\"Caught exception, continuing...: %s\", e)\n            continue\n\n    return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_current_ping_status","title":"<code>get_current_ping_status()</code>","text":"<p>Get current ping status (forced &gt; custom &gt; automatic).</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_current_ping_status(self) -&gt; PingStatus:\n    \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n    current_status = None\n\n    if self._forced_ping_status is not None:\n        current_status = self._forced_ping_status\n    elif self._ping_handler:\n        try:\n            result = self._ping_handler()\n            if isinstance(result, str):\n                current_status = PingStatus(result)\n            else:\n                current_status = result\n        except Exception as e:\n            self.logger.warning(\n                \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n            )\n\n    if current_status is None:\n        current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n    if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n        self._last_known_status = current_status\n        self._last_status_update_time = time.time()\n\n    return current_status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.ping","title":"<code>ping(func)</code>","text":"<p>Decorator to register a custom ping status handler.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as ping status handler</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def ping(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a custom ping status handler.\n\n    Args:\n        func: The function to register as ping status handler\n\n    Returns:\n        The decorated function\n    \"\"\"\n    self._ping_handler = func\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.run","title":"<code>run(port=8080, host=None)</code>","text":"<p>Start the Bedrock AgentCore server.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve on, defaults to 8080</p> <code>8080</code> <code>host</code> <code>Optional[str]</code> <p>Host to bind to, auto-detected if None</p> <code>None</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def run(self, port: int = 8080, host: Optional[str] = None):\n    \"\"\"Start the Bedrock AgentCore server.\n\n    Args:\n        port: Port to serve on, defaults to 8080\n        host: Host to bind to, auto-detected if None\n    \"\"\"\n    import os\n\n    import uvicorn\n\n    if host is None:\n        if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n            host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n        else:\n            host = \"127.0.0.1\"\n    uvicorn.run(self, host=host, port=port)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext","title":"<code>BedrockAgentCoreContext</code>","text":"<p>Context manager for Bedrock AgentCore.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class BedrockAgentCoreContext:\n    \"\"\"Context manager for Bedrock AgentCore.\"\"\"\n\n    _workload_access_token: ContextVar[str] = ContextVar(\"workload_access_token\")\n\n    @classmethod\n    def set_workload_access_token(cls, token: str):\n        \"\"\"Set the workload access token in the context.\"\"\"\n        cls._workload_access_token.set(token)\n\n    @classmethod\n    def get_workload_access_token(cls) -&gt; Optional[str]:\n        \"\"\"Get the workload access token from the context.\"\"\"\n        try:\n            return cls._workload_access_token.get()\n        except LookupError:\n            return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_workload_access_token","title":"<code>get_workload_access_token()</code>  <code>classmethod</code>","text":"<p>Get the workload access token from the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_workload_access_token(cls) -&gt; Optional[str]:\n    \"\"\"Get the workload access token from the context.\"\"\"\n    try:\n        return cls._workload_access_token.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.set_workload_access_token","title":"<code>set_workload_access_token(token)</code>  <code>classmethod</code>","text":"<p>Set the workload access token in the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef set_workload_access_token(cls, token: str):\n    \"\"\"Set the workload access token in the context.\"\"\"\n    cls._workload_access_token.set(token)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.PingStatus","title":"<code>PingStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Ping status enum for health check responses.</p> Source code in <code>bedrock_agentcore/runtime/models.py</code> <pre><code>class PingStatus(str, Enum):\n    \"\"\"Ping status enum for health check responses.\"\"\"\n\n    HEALTHY = \"Healthy\"\n    HEALTHY_BUSY = \"HealthyBusy\"\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.RequestContext","title":"<code>RequestContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request context containing metadata from HTTP requests.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class RequestContext(BaseModel):\n    \"\"\"Request context containing metadata from HTTP requests.\"\"\"\n\n    session_id: Optional[str] = Field(None)\n</code></pre>"},{"location":"api-reference/tools.html","title":"Tools","text":"<p>Tools and utilities for Bedrock AgentCore SDK including browser and code interpreter tools.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client","title":"<code>bedrock_agentcore.tools.code_interpreter_client</code>","text":"<p>Client for interacting with the Code Interpreter sandbox service.</p> <p>This module provides a client for the AWS Code Interpreter sandbox, allowing applications to start, stop, and invoke code execution in a managed sandbox environment.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter","title":"<code>CodeInterpreter</code>","text":"<p>Client for interacting with the AWS Code Interpreter sandbox service.</p> <p>This client handles the session lifecycle and method invocation for Code Interpreter sandboxes, providing an interface to execute code in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The code interpreter identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>class CodeInterpreter:\n    \"\"\"Client for interacting with the AWS Code Interpreter sandbox service.\n\n    This client handles the session lifecycle and method invocation for\n    Code Interpreter sandboxes, providing an interface to execute code\n    in a secure, managed environment.\n\n    Attributes:\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The code interpreter identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str) -&gt; None:\n        \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Code Interpreter service.\n        \"\"\"\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        self.client = boto3.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current code interpreter identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the code interpreter identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n    ) -&gt; str:\n        \"\"\"Start a code interpreter sandbox session.\n\n        This method initializes a new code interpreter session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The code interpreter sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            description (Optional[str]): A description for this session.\n                Defaults to an empty string.\n\n        Returns:\n            str: The session ID of the newly created session.\n        \"\"\"\n        response = self.client.start_code_interpreter_session(\n            codeInterpreterIdentifier=identifier,\n            name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n            sessionTimeoutSeconds=session_timeout_seconds,\n        )\n\n        self.identifier = response[\"codeInterpreterIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current code interpreter session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_code_interpreter_session(\n            **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n        )\n\n        self.identifier = None\n        self.session_id = None\n\n    def invoke(self, method: str, params: Optional[Dict] = None):\n        \"\"\"Invoke a method in the code interpreter sandbox.\n\n        If no session is active, this method automatically starts a new session\n        before invoking the requested method.\n\n        Args:\n            method (str): The name of the method to invoke in the sandbox.\n            params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n            request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n        Returns:\n            dict: The response from the code interpreter service.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            self.start()\n\n        return self.client.invoke_code_interpreter(\n            **{\n                \"codeInterpreterIdentifier\": self.identifier,\n                \"sessionId\": self.session_id,\n                \"name\": method,\n                \"arguments\": params or {},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current code interpreter identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize a Code Interpreter client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def __init__(self, region: str) -&gt; None:\n    \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n    \"\"\"\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    self.client = boto3.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.invoke","title":"<code>invoke(method, params=None)</code>","text":"<p>Invoke a method in the code interpreter sandbox.</p> <p>If no session is active, this method automatically starts a new session before invoking the requested method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to invoke in the sandbox.</p> required <code>params</code> <code>Optional[Dict]</code> <p>Parameters to pass to the method. Defaults to None.</p> <code>None</code> <code>request_id</code> <code>Optional[str]</code> <p>A custom request ID. If not provided, a unique ID is generated.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the code interpreter service.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def invoke(self, method: str, params: Optional[Dict] = None):\n    \"\"\"Invoke a method in the code interpreter sandbox.\n\n    If no session is active, this method automatically starts a new session\n    before invoking the requested method.\n\n    Args:\n        method (str): The name of the method to invoke in the sandbox.\n        params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n        request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n    Returns:\n        dict: The response from the code interpreter service.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        self.start()\n\n    return self.client.invoke_code_interpreter(\n        **{\n            \"codeInterpreterIdentifier\": self.identifier,\n            \"sessionId\": self.session_id,\n            \"name\": method,\n            \"arguments\": params or {},\n        }\n    )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_TIMEOUT)</code>","text":"<p>Start a code interpreter sandbox session.</p> <p>This method initializes a new code interpreter session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The code interpreter sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_TIMEOUT</code> <code>description</code> <code>Optional[str]</code> <p>A description for this session. Defaults to an empty string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n) -&gt; str:\n    \"\"\"Start a code interpreter sandbox session.\n\n    This method initializes a new code interpreter session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The code interpreter sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        description (Optional[str]): A description for this session.\n            Defaults to an empty string.\n\n    Returns:\n        str: The session ID of the newly created session.\n    \"\"\"\n    response = self.client.start_code_interpreter_session(\n        codeInterpreterIdentifier=identifier,\n        name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n        sessionTimeoutSeconds=session_timeout_seconds,\n    )\n\n    self.identifier = response[\"codeInterpreterIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.stop","title":"<code>stop()</code>","text":"<p>Stop the current code interpreter session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current code interpreter session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_code_interpreter_session(\n        **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n    )\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.code_session","title":"<code>code_session(region)</code>","text":"<p>Context manager for creating and managing a code interpreter session.</p> <p>This context manager handles creating a client, starting a session, and ensuring the session is properly cleaned up when the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required <p>Yields:</p> Name Type Description <code>CodeInterpreterClient</code> <code>CodeInterpreter</code> <p>An initialized and started code interpreter client.</p> Example <p>with code_session('us-west-2') as client: ...     result = client.invoke('listFiles') ...     # Process result here</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>@contextmanager\ndef code_session(region: str) -&gt; Generator[CodeInterpreter, None, None]:\n    \"\"\"Context manager for creating and managing a code interpreter session.\n\n    This context manager handles creating a client, starting a session, and\n    ensuring the session is properly cleaned up when the context exits.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n\n    Yields:\n        CodeInterpreterClient: An initialized and started code interpreter client.\n\n    Example:\n        &gt;&gt;&gt; with code_session('us-west-2') as client:\n        ...     result = client.invoke('listFiles')\n        ...     # Process result here\n    \"\"\"\n    client = CodeInterpreter(region)\n    client.start()\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client","title":"<code>bedrock_agentcore.tools.browser_client</code>","text":"<p>Client for interacting with the Browser sandbox service.</p> <p>This module provides a client for the AWS Browser sandbox, allowing applications to start, stop, and automate browser interactions in a managed sandbox environment using Playwright.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient","title":"<code>BrowserClient</code>","text":"<p>Client for interacting with the AWS Browser sandbox service.</p> <p>This client handles the session lifecycle and browser automation for Browser sandboxes, providing an interface to perform web automation tasks in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>region</code> <code>str</code> <p>The AWS region being used.</p> <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The browser identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>class BrowserClient:\n    \"\"\"Client for interacting with the AWS Browser sandbox service.\n\n    This client handles the session lifecycle and browser automation for\n    Browser sandboxes, providing an interface to perform web automation\n    tasks in a secure, managed environment.\n\n    Attributes:\n        region (str): The AWS region being used.\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The browser identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str) -&gt; None:\n        \"\"\"Initialize a Browser client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Browser service.\n        \"\"\"\n        self.region = region\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        self.client = boto3.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n        self.logger = logging.getLogger(__name__)\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current browser identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the browser identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n    ) -&gt; str:\n        \"\"\"Start a browser sandbox session.\n\n        This method initializes a new browser session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The browser sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            description (Optional[str]): A description for this session.\n                Defaults to an empty string.\n\n        Returns:\n            str: The session ID of the newly created session.\n        \"\"\"\n        self.logger.info(\"Starting browser session...\")\n\n        response = self.client.start_browser_session(\n            browserIdentifier=identifier,\n            name=name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n            sessionTimeoutSeconds=session_timeout_seconds,\n        )\n\n        self.identifier = response[\"browserIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current browser session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        self.logger.info(\"Stopping browser session...\")\n\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n        self.identifier = None\n        self.session_id = None\n\n    def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n        \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n        This method creates properly signed WebSocket headers for connecting to\n        the browser automation endpoint.\n\n        Returns:\n            Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n                the headers dictionary.\n\n        Raises:\n            RuntimeError: If no AWS credentials are found.\n        \"\"\"\n        self.logger.info(\"Generating websocket headers...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n        path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n        ws_url = f\"wss://{host}{path}\"\n\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials()\n        if not credentials:\n            raise RuntimeError(\"No AWS credentials found\")\n\n        frozen_credentials = credentials.get_frozen_credentials()\n\n        request = AWSRequest(\n            method=\"GET\",\n            url=f\"https://{host}{path}\",\n            headers={\n                \"host\": host,\n                \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n            },\n        )\n\n        auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n        auth.add_auth(request)\n\n        headers = {\n            \"Host\": host,\n            \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n            \"Authorization\": request.headers[\"Authorization\"],\n            \"Upgrade\": \"websocket\",\n            \"Connection\": \"Upgrade\",\n            \"Sec-WebSocket-Version\": \"13\",\n            \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n            \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n        }\n\n        if frozen_credentials.token:\n            headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n        return ws_url, headers\n\n    def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n        \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n        Creates a pre-signed URL that can be used to view the current browser session.\n        If no session is active, a new session will be started.\n\n        Args:\n            expires (int, optional): The number of seconds until the pre-signed URL expires.\n                Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n\n        Returns:\n            str: The pre-signed URL for viewing the browser session.\n\n        Raises:\n            RuntimeError: If the URL generation fails.\n        \"\"\"\n        self.logger.info(\"Generating live view url...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        url = urlparse(\n            f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n        )\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials().get_frozen_credentials()\n        request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n        signer = SigV4QueryAuth(\n            credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n        )\n        signer.add_auth(request)\n\n        if not request.url:\n            raise RuntimeError(\"Failed to generate live view url\")\n\n        return request.url\n\n    def take_control(self):\n        \"\"\"Take control of the browser session by disabling the automation stream.\n\n        This method disables external automation capabilities of the browser session,\n        giving this client exclusive control. If no session is active, a new session\n        will be started.\n\n        Raises:\n            RuntimeError: If a session could not be found or started.\n        \"\"\"\n        self.logger.info(\"Taking control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        if not self.identifier or not self.session_id:\n            raise RuntimeError(\"Could not find or start a browser session\")\n\n        self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n\n    def release_control(self):\n        \"\"\"Release control of the browser session by enabling the automation stream.\n\n        This method enables external automation capabilities of the browser session,\n        relinquishing exclusive control. If no session exists, a warning is logged\n        and the method returns without taking action.\n        \"\"\"\n        self.logger.info(\"Releasing control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.logger.warning(\"Could not find a browser session when releasing control\")\n            return\n\n        self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n\n    def _update_browser_stream(self, identifier: str, session_id: str, stream_status: str) -&gt; None:\n        \"\"\"Update the browser stream status.\n\n        This private helper method updates the status of the browser automation stream.\n\n        Args:\n            identifier (str): The browser identifier.\n            session_id (str): The session ID.\n            stream_status (str): The status to set for the automation stream.\n                Valid values are \"ENABLED\" or \"DISABLED\".\n        \"\"\"\n        self.client.update_browser_stream(\n            **{\n                \"browserIdentifier\": identifier,\n                \"sessionId\": session_id,\n                \"streamUpdate\": {\"automationStreamUpdate\": {\"streamStatus\": stream_status}},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current browser identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize a Browser client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def __init__(self, region: str) -&gt; None:\n    \"\"\"Initialize a Browser client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n    \"\"\"\n    self.region = region\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    self.client = boto3.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_live_view_url","title":"<code>generate_live_view_url(expires=DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT)</code>","text":"<p>Generate a pre-signed URL for viewing the browser session.</p> <p>Creates a pre-signed URL that can be used to view the current browser session. If no session is active, a new session will be started.</p> <p>Parameters:</p> Name Type Description Default <code>expires</code> <code>int</code> <p>The number of seconds until the pre-signed URL expires. Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).</p> <code>DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The pre-signed URL for viewing the browser session.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the URL generation fails.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n    \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n    Creates a pre-signed URL that can be used to view the current browser session.\n    If no session is active, a new session will be started.\n\n    Args:\n        expires (int, optional): The number of seconds until the pre-signed URL expires.\n            Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n\n    Returns:\n        str: The pre-signed URL for viewing the browser session.\n\n    Raises:\n        RuntimeError: If the URL generation fails.\n    \"\"\"\n    self.logger.info(\"Generating live view url...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    url = urlparse(\n        f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n    )\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials().get_frozen_credentials()\n    request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n    signer = SigV4QueryAuth(\n        credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n    )\n    signer.add_auth(request)\n\n    if not request.url:\n        raise RuntimeError(\"Failed to generate live view url\")\n\n    return request.url\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_ws_headers","title":"<code>generate_ws_headers()</code>","text":"<p>Generate the WebSocket headers needed for connecting to the browser sandbox.</p> <p>This method creates properly signed WebSocket headers for connecting to the browser automation endpoint.</p> <p>Returns:</p> Type Description <code>Tuple[str, Dict[str, str]]</code> <p>Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and the headers dictionary.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no AWS credentials are found.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n    \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n    This method creates properly signed WebSocket headers for connecting to\n    the browser automation endpoint.\n\n    Returns:\n        Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n            the headers dictionary.\n\n    Raises:\n        RuntimeError: If no AWS credentials are found.\n    \"\"\"\n    self.logger.info(\"Generating websocket headers...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n    path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n    ws_url = f\"wss://{host}{path}\"\n\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials()\n    if not credentials:\n        raise RuntimeError(\"No AWS credentials found\")\n\n    frozen_credentials = credentials.get_frozen_credentials()\n\n    request = AWSRequest(\n        method=\"GET\",\n        url=f\"https://{host}{path}\",\n        headers={\n            \"host\": host,\n            \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n        },\n    )\n\n    auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n    auth.add_auth(request)\n\n    headers = {\n        \"Host\": host,\n        \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n        \"Authorization\": request.headers[\"Authorization\"],\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": \"13\",\n        \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n        \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n    }\n\n    if frozen_credentials.token:\n        headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n    return ws_url, headers\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.release_control","title":"<code>release_control()</code>","text":"<p>Release control of the browser session by enabling the automation stream.</p> <p>This method enables external automation capabilities of the browser session, relinquishing exclusive control. If no session exists, a warning is logged and the method returns without taking action.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def release_control(self):\n    \"\"\"Release control of the browser session by enabling the automation stream.\n\n    This method enables external automation capabilities of the browser session,\n    relinquishing exclusive control. If no session exists, a warning is logged\n    and the method returns without taking action.\n    \"\"\"\n    self.logger.info(\"Releasing control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.logger.warning(\"Could not find a browser session when releasing control\")\n        return\n\n    self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_SESSION_TIMEOUT)</code>","text":"<p>Start a browser sandbox session.</p> <p>This method initializes a new browser session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The browser sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_SESSION_TIMEOUT</code> <code>description</code> <code>Optional[str]</code> <p>A description for this session. Defaults to an empty string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n) -&gt; str:\n    \"\"\"Start a browser sandbox session.\n\n    This method initializes a new browser session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The browser sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        description (Optional[str]): A description for this session.\n            Defaults to an empty string.\n\n    Returns:\n        str: The session ID of the newly created session.\n    \"\"\"\n    self.logger.info(\"Starting browser session...\")\n\n    response = self.client.start_browser_session(\n        browserIdentifier=identifier,\n        name=name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n        sessionTimeoutSeconds=session_timeout_seconds,\n    )\n\n    self.identifier = response[\"browserIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.stop","title":"<code>stop()</code>","text":"<p>Stop the current browser session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current browser session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    self.logger.info(\"Stopping browser session...\")\n\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.take_control","title":"<code>take_control()</code>","text":"<p>Take control of the browser session by disabling the automation stream.</p> <p>This method disables external automation capabilities of the browser session, giving this client exclusive control. If no session is active, a new session will be started.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a session could not be found or started.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def take_control(self):\n    \"\"\"Take control of the browser session by disabling the automation stream.\n\n    This method disables external automation capabilities of the browser session,\n    giving this client exclusive control. If no session is active, a new session\n    will be started.\n\n    Raises:\n        RuntimeError: If a session could not be found or started.\n    \"\"\"\n    self.logger.info(\"Taking control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    if not self.identifier or not self.session_id:\n        raise RuntimeError(\"Could not find or start a browser session\")\n\n    self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.browser_session","title":"<code>browser_session(region)</code>","text":"<p>Context manager for creating and managing a browser sandbox session.</p> <p>This context manager handles creating a client, starting a session, and ensuring the session is properly cleaned up when the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required <p>Yields:</p> Name Type Description <code>BrowserClient</code> <code>BrowserClient</code> <p>An initialized and started browser client.</p> Example <p>with browser_session('us-west-2') as client: ...     browser = client.get_browser_obj() ...     page = browser.new_page() ...     page.goto('https://example.com')</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>@contextmanager\ndef browser_session(region: str) -&gt; Generator[BrowserClient, None, None]:\n    \"\"\"Context manager for creating and managing a browser sandbox session.\n\n    This context manager handles creating a client, starting a session, and\n    ensuring the session is properly cleaned up when the context exits.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n\n    Yields:\n        BrowserClient: An initialized and started browser client.\n\n    Example:\n        &gt;&gt;&gt; with browser_session('us-west-2') as client:\n        ...     browser = client.get_browser_obj()\n        ...     page = browser.new_page()\n        ...     page.goto('https://example.com')\n    \"\"\"\n    client = BrowserClient(region)\n    client.start()\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"examples/index.html","title":"Examples","text":"<p>These simple examples demonstrate key Amazon Bedrock AgentCore concepts and patterns. Each example focuses on a specific capability, making it easy to understand and adapt for your own agents. For more comprehensive examples and production-ready samples, explore the Amazon Bedrock AgentCore Samples repository.</p>"},{"location":"examples/async-processing.html","title":"Async Processing","text":"<p>This example demonstrates how to use Bedrock AgentCore's <code>@async_task</code> decorator for automatic health status management.</p>"},{"location":"examples/async-processing.html#overview","title":"Overview","text":"<p>Bedrock AgentCore provides automatic ping status management based on running async tasks:</p> <ul> <li>Automatic Health Reporting: Ping status automatically reflects system busyness</li> <li>Simple Integration: Just use the <code>@async_task</code> decorator</li> <li>Zero Configuration: Status tracking works out of the box</li> </ul>"},{"location":"examples/async-processing.html#key-concepts","title":"Key Concepts","text":"<ul> <li><code>Healthy</code>: System ready for new work</li> <li><code>HealthyBusy</code>: System busy with async tasks</li> </ul>"},{"location":"examples/async-processing.html#simple-agent-example","title":"Simple Agent Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple agent demonstrating @async_task decorator usage.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n# Long-running task that automatically affects ping status\n@app.async_task\nasync def process_data(data_id: str):\n    \"\"\"Process data asynchronously - status becomes 'HealthyBusy' during execution.\"\"\"\n    print(f\"[{datetime.now()}] Processing data: {data_id}\")\n\n    # Simulate processing work\n    await asyncio.sleep(30)  # Long-running task\n\n    print(f\"[{datetime.now()}] Completed processing: {data_id}\")\n    return f\"Processed {data_id}\"\n\n# Another background task\n@app.async_task\nasync def cleanup_task():\n    \"\"\"Cleanup task that also affects ping status.\"\"\"\n    print(f\"[{datetime.now()}] Starting cleanup...\")\n    await asyncio.sleep(10)\n    print(f\"[{datetime.now()}] Cleanup completed\")\n    return \"Cleanup done\"\n\n@app.entrypoint\nasync def handler(event):\n    \"\"\"Main handler - starts async tasks.\"\"\"\n    action = event.get(\"action\", \"info\")\n\n    if action == \"process\":\n        data_id = event.get(\"data_id\", \"default_data\")\n        # Start the async task (status will become HealthyBusy)\n        await process_data(data_id)\n        return {\"message\": f\"Processing {data_id}\", \"status\": \"completed\"}\n\n    elif action == \"cleanup\":\n        # Start cleanup task\n        await cleanup_task()\n        return {\"message\": \"Cleanup completed\"}\n\n    elif action == \"status\":\n        # Get current status\n        task_info = app.get_async_task_info()\n        current_status = app.get_current_ping_status()\n\n        return {\n            \"ping_status\": current_status.value,\n            \"active_tasks\": task_info[\"active_count\"],\n            \"running_jobs\": task_info[\"running_jobs\"]\n        }\n\n    else:\n        return {\n            \"message\": \"Simple BedrockAgentCore Agent\",\n            \"available_actions\": [\"process\", \"cleanup\", \"status\"],\n            \"usage\": \"Send {'action': 'process', 'data_id': 'my_data'}\"\n        }\n\nif __name__ == \"__main__\":\n    print(\"Starting simple BedrockAgentCore agent...\")\n    print(\"The agent will automatically report 'HealthyBusy' when processing tasks\")\n    app.run()\n</code></pre>"},{"location":"examples/async-processing.html#how-it-works","title":"How It Works","text":"<ol> <li>Decorate async functions with <code>@app.async_task</code></li> <li>Call the functions normally in your handler</li> <li>Status updates automatically:</li> <li><code>Healthy</code> when no tasks are running</li> <li><code>HealthyBusy</code> when any <code>@async_task</code> function is executing</li> </ol>"},{"location":"examples/async-processing.html#usage-examples","title":"Usage Examples","text":"<pre><code># Check current ping status\ncurl http://localhost:8080/ping\n\n# Start processing (status will become HealthyBusy)\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"process\", \"data_id\": \"sample_data\"}'\n\n# Check status while processing\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"status\"}'\n\n# Run cleanup task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"cleanup\"}'\n</code></pre>"},{"location":"examples/async-processing.html#key-benefits","title":"Key Benefits","text":"<ol> <li>Automatic Status Tracking: No manual ping status management needed</li> <li>Cost Control: Status automatically prevents new work assignment when busy</li> <li>Simple to Use: Just add <code>@async_task</code> decorator to long-running functions</li> <li>Error Handling: Status correctly updates even if tasks fail</li> </ol> <p>This simple pattern provides automatic health monitoring for your BedrockAgentCore applications without any additional configuration.</p>"},{"location":"examples/gateway-integration.html","title":"Gateway Integration Examples","text":""},{"location":"examples/gateway-integration.html#lambda-function-as-mcp-tool","title":"Lambda Function as MCP Tool","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\n\nclient = GatewayClient(region_name='us-west-2')\n\n# Define Lambda tools with detailed schemas\nlambda_config = {\n    \"arn\": \"arn:aws:lambda:us-west-2:123:function:DataProcessor\",\n    \"tools\": [\n        {\n            \"name\": \"process_data\",\n            \"description\": \"Process user data in JSON or CSV format\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"},\n                    \"format\": {\"type\": \"string\"}  # Note: enum not supported, document in description\n                },\n                \"required\": [\"data\", \"format\"]\n            }\n        },\n        {\n            \"name\": \"validate_data\",\n            \"description\": \"Validate data structure\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"}\n                },\n                \"required\": [\"data\"]\n            }\n        }\n    ]\n}\n\n# Create Gateway with semantic search enabled\ncognito = client.create_oauth_authorizer_with_cognito(\"data-processor\")\ngateway = client.setup_gateway(\n    gateway_name=\"data-processor\",\n    target_source=json.dumps(lambda_config),\n    execution_role_arn=\"arn:aws:iam::123:role/ExecutionRole\",\n    authorizer_config=cognito['authorizer_config'],\n    target_type='lambda',\n    enable_semantic_search=True,\n    description=\"Data processing gateway with validation tools\"\n)\n\nprint(f\"Gateway created: {gateway.get_mcp_url()}\")\n</code></pre>"},{"location":"examples/gateway-integration.html#openapi-integration","title":"OpenAPI Integration","text":""},{"location":"examples/gateway-integration.html#from-s3","title":"From S3","text":"<pre><code>gateway = client.setup_gateway(\n    gateway_name=\"my-api\",\n    target_source=\"s3://my-bucket/api-spec.json\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#inline-openapi-specification","title":"Inline OpenAPI Specification","text":"<pre><code>openapi_spec = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"User API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"https://api.example.com\"}],\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"operationId\": \"listUsers\",\n                \"summary\": \"List all users\",\n                \"responses\": {\"200\": {\"description\": \"User list\"}}\n            }\n        },\n        \"/users/{id}\": {\n            \"get\": {\n                \"operationId\": \"getUser\",\n                \"summary\": \"Get user by ID\",\n                \"parameters\": [{\n                    \"name\": \"id\",\n                    \"in\": \"path\",\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"}\n                }],\n                \"responses\": {\"200\": {\"description\": \"User found\"}}\n            }\n        }\n    }\n}\n\ngateway = client.setup_gateway(\n    gateway_name=\"user-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#yaml-openapi-from-file","title":"YAML OpenAPI (from file)","text":"<pre><code>import yaml\n\n# Load YAML OpenAPI spec\nwith open('openapi.yaml', 'r') as f:\n    yaml_content = f.read()\n    openapi_spec = yaml.safe_load(yaml_content)\n\n# Convert to JSON string for inline use\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n\n# Or use S3 (YAML files work directly)\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=\"s3://my-bucket/openapi.yaml\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#oauth-token-management","title":"OAuth Token Management","text":"<p>When integrating Gateway with any agent framework, you'll need to handle OAuth tokens properly:</p> <pre><code>import os\nfrom datetime import datetime, timedelta\nimport httpx\nimport asyncio\n\nclass GatewayTokenManager:\n    \"\"\"Manages OAuth tokens with automatic refresh\"\"\"\n\n    def __init__(self, client_id, client_secret, token_endpoint, scope):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.token_endpoint = token_endpoint\n        self.scope = scope\n        self._token = None\n        self._expires_at = None\n\n    async def get_token(self):\n        \"\"\"Get valid token, refreshing if needed\"\"\"\n        if self._token and self._expires_at &gt; datetime.now():\n            return self._token\n\n        # Fetch new token\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                self.token_endpoint,\n                data={\n                    'grant_type': 'client_credentials',\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                    'scope': self.scope\n                },\n                headers={'Content-Type': 'application/x-www-form-urlencoded'}\n            )\n            data = response.json()\n            self._token = data['access_token']\n            # Buffer expiry by 5 minutes\n            expires_in = data.get('expires_in', 3600) - 300\n            self._expires_at = datetime.now() + timedelta(seconds=expires_in)\n            return self._token\n</code></pre>"},{"location":"examples/gateway-integration.html#generic-agent-integration","title":"Generic Agent Integration","text":"<p>Here's how to integrate Gateway with any agent framework:</p> <pre><code>import os\nimport asyncio\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize token manager with Gateway credentials\ntoken_manager = GatewayTokenManager(\n    client_id=os.environ['GATEWAY_CLIENT_ID'],\n    client_secret=os.environ['GATEWAY_CLIENT_SECRET'],\n    token_endpoint=os.environ['GATEWAY_TOKEN_ENDPOINT'],\n    scope=os.environ['GATEWAY_SCOPE']\n)\n\n# Gateway MCP endpoint\nGATEWAY_URL = os.environ['GATEWAY_MCP_URL']\n\n# Generic function to call Gateway tools\nasync def call_gateway_tool(tool_name: str, arguments: dict):\n    \"\"\"Call any tool exposed through Gateway\"\"\"\n    token = await token_manager.get_token()\n\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            GATEWAY_URL,\n            headers={\n                \"Authorization\": f\"Bearer {token}\",\n                \"Content-Type\": \"application/json\"\n            },\n            json={\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"method\": \"tools/call\",\n                \"params\": {\n                    \"name\": tool_name,\n                    \"arguments\": arguments\n                }\n            }\n        )\n\n        result = response.json()\n        if 'error' in result:\n            raise Exception(f\"Tool error: {result['error']}\")\n\n        return result.get('result')\n\n# Example: Using in your agent logic\nasync def process_user_request(user_message: str):\n    # Parse intent from user message\n    if \"weather\" in user_message.lower():\n        # Extract location (this would be done by your agent's NLU)\n        location = extract_location(user_message)\n        weather_data = await call_gateway_tool(\"get_weather\", {\"location\": location})\n        return f\"The weather in {location} is: {weather_data}\"\n\n    elif \"user\" in user_message.lower():\n        # Get user information\n        user_id = extract_user_id(user_message)\n        user_data = await call_gateway_tool(\"getUser\", {\"id\": user_id})\n        return f\"User information: {user_data}\"\n\n    return \"I couldn't understand your request.\"\n</code></pre>"},{"location":"examples/gateway-integration.html#complete-example-weather-agent","title":"Complete Example: Weather Agent","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\nimport asyncio\nimport httpx\n\n# Step 1: Create Gateway\nasync def setup_weather_gateway():\n    client = GatewayClient(region_name='us-west-2')\n\n    # Configure Lambda with weather tools\n    lambda_config = {\n        \"arn\": \"arn:aws:lambda:us-west-2:123:function:WeatherService\",\n        \"tools\": [\n            {\n                \"name\": \"get_current_weather\",\n                \"description\": \"Get current weather for a city\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"country\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            },\n            {\n                \"name\": \"get_forecast\",\n                \"description\": \"Get 5-day weather forecast\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"days\": {\"type\": \"number\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            }\n        ]\n    }\n\n    # Create Gateway with EZ Auth\n    cognito = client.create_oauth_authorizer_with_cognito(\"weather-service\")\n    gateway = client.setup_gateway(\n        gateway_name=\"weather-service\",\n        target_source=json.dumps(lambda_config),\n        execution_role_arn=\"arn:aws:iam::123:role/WeatherExecutionRole\",\n        authorizer_config=cognito['authorizer_config'],\n        target_type='lambda',\n        enable_semantic_search=True\n    )\n\n    return gateway, cognito['client_info']\n\n# Step 2: Use the Gateway\nasync def weather_agent():\n    gateway, client_info = await setup_weather_gateway()\n\n    # Initialize token manager\n    token_manager = GatewayTokenManager(\n        client_id=client_info['client_id'],\n        client_secret=client_info['client_secret'],\n        token_endpoint=client_info['token_endpoint'],\n        scope=client_info['scope']\n    )\n\n    # Get weather for multiple cities\n    cities = [\"Seattle\", \"New York\", \"London\"]\n\n    for city in cities:\n        token = await token_manager.get_token()\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                gateway.get_mcp_url(),\n                headers={\"Authorization\": f\"Bearer {token}\"},\n                json={\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": 1,\n                    \"method\": \"tools/call\",\n                    \"params\": {\n                        \"name\": \"get_current_weather\",\n                        \"arguments\": {\"city\": city}\n                    }\n                }\n            )\n\n            result = response.json()\n            print(f\"Weather in {city}: {result.get('result')}\")\n\n# Run the agent\nif __name__ == \"__main__\":\n    asyncio.run(weather_agent())\n</code></pre>"},{"location":"examples/session-management.html","title":"Session Management","text":"<p>Agent that maintains conversation state using session IDs.</p>"},{"location":"examples/session-management.html#handler-code","title":"Handler Code","text":"<pre><code># handler.py\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.context import RequestContext\n\napp = BedrockAgentCoreApp()\n\n# Simple in-memory session storage (use database in production)\nsessions = {}\n\n@app.entrypoint\ndef chat_handler(payload, context: RequestContext):\n    \"\"\"Handle chat with session management\"\"\"\n    session_id = context.session_id or \"default\"\n    message = payload.get(\"message\", \"\")\n\n    # Initialize session if new\n    if session_id not in sessions:\n        sessions[session_id] = {\n            \"messages\": [],\n            \"count\": 0\n        }\n\n    # Add message to session\n    sessions[session_id][\"messages\"].append(message)\n    sessions[session_id][\"count\"] += 1\n\n    # Generate response\n    count = sessions[session_id][\"count\"]\n    return {\n        \"response\": f\"Message {count}: You said '{message}'\",\n        \"session_id\": session_id,\n        \"message_count\": count\n    }\n\napp.run()\n</code></pre>"},{"location":"examples/session-management.html#usage","title":"Usage","text":""},{"location":"examples/session-management.html#cli","title":"CLI","text":"<pre><code>agentcore configure --entrypoint handler.py\nagentcore launch\n\n# Start conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv1\n\n# Continue conversation\nagentcore invoke '{\"message\": \"How are you?\"}' --session-id conv1\n\n# Session id is automatically persisted and reused in .bedrock_agentcore.yaml\nagentcore invoke '{\"message\": \"Goodbye\"}'\n\n# Start a new conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv2\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html","title":"Getting Started with Browser","text":"<p>The Amazon Bedrock AgentCore Browser provides a secure, managed environment for web browsing and automation. This guide will help you implement powerful browser capabilities in your agent applications.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#prerequisites","title":"Prerequisites","text":"<p>Before using the browser tool, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#create-a-browser-session","title":"Create a Browser Session","text":"<p>The bedrock-agentcore SDK provides a convenient way to create browser sessions:</p> <pre><code>from bedrock_agentcore.tools.browser_client import browser_session\n\n# Create a browser session using the context manager\nwith browser_session(\"us-west-2\") as client:\n    # The session_id is automatically generated\n    print(f\"Session ID: {client.session_id}\")\n\n    # Generate WebSocket URL and headers for connecting automation frameworks\n    websocket_url, headers = client.generate_ws_headers()\n\n    # Use these to connect your preferred browser automation tool\n    # (See examples below)\n\n# The session is automatically closed when exiting the context manager\n</code></pre> <p>For more control over the session lifecycle:</p> <pre><code>from bedrock_agentcore.tools.browser_client import BrowserClient\n\n# Create a browser client\nclient = BrowserClient(region=\"us-west-2\")\n\n# Start a browser session\nclient.start()\nprint(f\"Session ID: {client.session_id}\")\n\ntry:\n    # Generate WebSocket URL and headers\n    url, headers = client.generate_ws_headers()\n\n    # Perform browser operations with your preferred automation tool\n\nfinally:\n    # Always close the session when done\n    client.stop()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#integration-examples","title":"Integration Examples","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#example-1-browser-automation-with-nova-act","title":"Example 1: Browser Automation with Nova Act","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-dependencies","title":"Install dependencies","text":"<p><pre><code>pip install nova-act\n</code></pre> You can build a browser agent using Nova Act to automate web interactions:</p> <pre><code>import time\nfrom bedrock_agentcore.tools.browser_client import browser_session\nfrom nova_act import NovaAct\nfrom rich.console import Console\n\nNOVA_ACT_API_KEY = \"YOUR_NOVA_ACT_API_KEY\"\n\nconsole = Console()\n\ndef main():\n    try:\n        # Step 1: Create browser session\n        with browser_session(\"us-west-2\") as client:\n            print(\"\\r   \u2705 Browser ready!                    \")\n            ws_url, headers = client.generate_ws_headers()\n\n            # Step 2: Use Nova Act to interact with the browser\n            with NovaAct(\n                    cdp_endpoint_url=ws_url,\n                    cdp_headers=headers,\n                    preview={\"playwright_actuation\": True},\n                    nova_act_api_key=NOVA_ACT_API_KEY,\n                    starting_page=\"https://www.amazon.com\",\n                ) as nova_act:\n                    result = nova_act.act(\"Search for coffee maker and get the details of the lowest priced one on the first page\")\n                    console.print(f\"\\n[bold green]Nova Act Result:[/bold green] {result}\")\n\n    except KeyboardInterrupt:\n        console.print(\"\\n\\n[yellow]Shutting down...[/yellow]\")\n        if 'client' in locals():\n            client.stop()\n            print(\"\u2705 Browser session terminated\")\n    except Exception as e:\n        print(f\"\\n[red]Error: {e}[/red]\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#example-2-using-playwright-for-browser-control","title":"Example 2: Using Playwright for Browser Control","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-dependencies_1","title":"Install dependencies","text":"<pre><code>pip install playwright\n</code></pre> <p>You can use the Playwright automation framework with the Browser Tool:</p> <pre><code>import time\nimport base64\nfrom datetime import datetime\nfrom playwright.sync_api import sync_playwright, Playwright, BrowserType\nfrom bedrock_agentcore.tools.browser_client import browser_session\n\ndef capture_cdp_screenshot(context, page, filename_prefix=\"screenshot\", image_format=\"jpeg\"):\n    \"\"\"Capture a screenshot using the CDP API and save to file.\"\"\"\n    cdp_client = context.new_cdp_session(page)\n    screenshot_data = cdp_client.send(\"Page.captureScreenshot\", {\n        \"format\": image_format,\n        \"quality\": 80,\n        \"captureBeyondViewport\": True\n    })\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{filename_prefix}_{timestamp}.{image_format}\"\n    image_bytes = base64.b64decode(screenshot_data['data'])\n\n    with open(filename, \"wb\") as f:\n        f.write(image_bytes)\n\n    print(f\"\u2705 Screenshot saved: {filename}\")\n    return filename\n\n\ndef main(playwright: Playwright):\n    with browser_session(\"us-west-2\") as client:\n        print(\"\ud83d\udce1 Browser session started... waiting for readiness\")\n\n        ws_url, headers = client.generate_ws_headers()\n        chromium: BrowserType = playwright.chromium\n        browser = chromium.connect_over_cdp(ws_url, headers=headers)\n\n        try:\n            context = browser.contexts[0] if browser.contexts else browser.new_context()\n            page = context.pages[0] if context.pages else context.new_page()\n\n            # Step 1: Navigate to Amazon\n            print(\"\ud83c\udf10 Navigating to Amazon...\")\n            page.goto(\"https://www.amazon.com\", wait_until=\"domcontentloaded\")\n            time.sleep(2)\n            capture_cdp_screenshot(context, page, \"amazon_home\")\n\n            # Step 2: Search for \"coffee maker\"\n            print(\"\ud83d\udd0e Searching for 'coffee maker'...\")\n            page.fill(\"input#twotabsearchtextbox\", \"coffee maker\")\n            page.keyboard.press(\"Enter\")\n            page.wait_for_selector(\".s-result-item\", timeout=10000)\n            time.sleep(2)\n            capture_cdp_screenshot(context, page, \"coffee_maker_results\")\n\n        finally:\n            print(\"\ud83d\udd12 Closing browser session...\")\n            if not page.is_closed():\n                page.close()\n            browser.close()\n\n\nif __name__ == \"__main__\":\n    with sync_playwright() as p:\n        main(p)\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#browser-tool-architecture","title":"Browser Tool Architecture","text":"<p>The AWS Browser Tool provides:</p> <ul> <li>Fully managed browser environment running in the AWS cloud</li> <li>WebSocket-based CDP interface for browser control</li> <li>Integration with popular automation frameworks like Playwright, Puppeteer, and NovaAct</li> <li>Security and isolation between browser sessions</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#best-practices","title":"Best Practices","text":"<p>To get the most out of the browser tool:</p> <ol> <li>Use context managers for proper resource cleanup</li> <li>Handle exceptions properly to ensure browser sessions are closed</li> <li>Consider performance when making multiple browser requests</li> <li>Secure sensitive data - never hardcode credentials in browser automation code</li> <li>Use appropriate timeouts for network and page load operations</li> <li>Add error recovery for common browser automation challenges</li> </ol>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html","title":"Getting Started with Code Interpreter","text":"<p>The Amazon Bedrock AgentCore Code Interpreter provides a secure environment for executing code snippets directly within your agent applications. This guide will help you get started with implementing code execution capabilities in your agents.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#prerequisites","title":"Prerequisites","text":"<p>Before using the Code Interpreter, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#create-a-code-interpreter-session","title":"Create a Code Interpreter Session","text":"<p>The bedrock-agentcore SDK provides a convenient way to create code interpreter sessions using the managed code interpreter <code>aws.codeinterpreter.v1</code>:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import code_session\n\n# Create a code interpreter session using the context manager\nwith code_session(\"us-west-2\") as client:\n    # The session is automatically created and managed\n    print(f\"Code interpreter session created\")\n\n    # List files in the session\n    result = client.invoke(\"listFiles\")\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n\n# The session is automatically closed when exiting the context manager\n</code></pre> <p>If you need more control over the session lifecycle, you can also use the client without a context manager:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\n\n# Create a code interpreter client\nclient = CodeInterpreter(region=\"us-west-2\")\n\n# Start a code interpreter session\nclient.start()\nprint(f\"Code interpreter session started\")\n\ntry:\n    # Use the code interpreter\n    result = client.invoke(\"listFiles\")\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n\nfinally:\n    # Always close the session when done\n    client.stop()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#execute-code","title":"Execute Code","text":"<p>Use the <code>invoke</code> method to execute code in your session:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import code_session\n\nwith code_session(\"us-west-2\") as client:\n    # Execute Python code\n    code_to_execute = \"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Create plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title('Sine Wave')\nplt.xlabel('x')\nplt.ylabel('sin(x)')\nplt.grid(True)\nplt.show()\n\nprint(\"Code execution completed successfully!\")\n\"\"\"\n\n    # Execute the code\n    result = client.invoke(\"executeCode\", {\"language\": \"python\", \"code\": code_to_execute})\n\n    # Process the streaming results\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#integrating-with-agents","title":"Integrating with Agents","text":"<p>You can integrate the Code Interpreter with your agents to enable code execution capabilities:</p> <pre><code>import json\nfrom strands import Agent, tool\nfrom bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\n\n# Global code interpreter client\ncode_client = CodeInterpreter(\"us-west-2\")\n\n# Validation-focused system prompt\nSYSTEM_PROMPT = \"\"\"You are an AI assistant that validates answers through code execution.\nWhen asked about code, algorithms, or calculations, write Python code to verify your answers.\"\"\"\n\n\n@tool\ndef execute_python(code: str) -&gt; str:\n    \"\"\"Execute Python code in the code interpreter.\"\"\"\n\n    # Show the code being executed\n    print(\"\\nExecuting Python code:\")\n    print(code)\n\n    # Execute the code\n    response = code_client.invoke(\"executeCode\", {\"language\": \"python\", \"code\": code})\n\n    # Process the streaming results\n    output = []\n\n    for event in response[\"stream\"]:\n        if \"result\" in event and \"content\" in event[\"result\"]:\n            content = event[\"result\"][\"content\"]\n            output.append(content)\n            print(content)\n\n    return json.dumps(output[-1])\n\n\ndef demo():\n    \"\"\"Main function demonstrating the code interpreter agent\"\"\"\n    try:\n        code_client.start()\n\n        # Create the agent with the execute_python tool\n        agent = Agent(\n            tools=[execute_python],\n            system_prompt=SYSTEM_PROMPT,\n        )\n\n        prompt = \"Calculate the first 10 Fibonacci numbers.\"\n        print(f\"\\nPrompt: {prompt}\\n\")\n\n        response = agent(prompt)\n        # Print the response\n        print(\"\\nAgent Response:\")\n        print(response.message)\n    finally:\n        code_client.stop()\n\n\nif __name__ == \"__main__\":\n    demo()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#best-practices","title":"Best Practices","text":"<p>To get the most out of the Code Interpreter:</p> <ol> <li>Use context managers: The <code>code_session</code> context manager ensures proper cleanup</li> <li>Handle errors gracefully: Always include try/except blocks</li> <li>Process streaming results: Code execution results are returned as streams</li> <li>Manage files properly: Clean up temporary files when no longer needed</li> <li>Close sessions: Always close sessions when done to release resources</li> </ol>"},{"location":"user-guide/gateway/overview.html","title":"Gateway CLI Overview","text":"<p>Bedrock AgentCore Gateway provides a simple CLI for creating and managing gateways.</p>"},{"location":"user-guide/gateway/overview.html#installation","title":"Installation","text":"<pre><code># Install Bedrock AgentCore SDK with Gateway support\npip install -e .\n# or\nuv pip install -e .\n\n# Verify installation\nagentcore --help\n</code></pre>"},{"location":"user-guide/gateway/overview.html#create-a-gateway","title":"Create a Gateway","text":"<p>The <code>agentcore gateway</code> command creates a new Gateway with automatic setup:</p> <pre><code>agentcore gateway \\\n  --name my-gateway \\\n  --target arn:aws:lambda:us-west-2:123456789012:function:MyFunction \\\n  --execution-role MyExecutionRole\n</code></pre>"},{"location":"user-guide/gateway/overview.html#command-syntax","title":"Command Syntax","text":"<pre><code>agentcore gateway [OPTIONS]\n</code></pre>"},{"location":"user-guide/gateway/overview.html#options","title":"Options","text":"Option Short Required Description <code>--name</code> <code>-n</code> Yes Gateway name <code>--target</code> <code>-t</code> Yes Target source (Lambda ARN, file path, or S3 URI) <code>--execution-role</code> <code>-r</code> Yes IAM execution role (ARN or name) <code>--type</code> No Target type (auto-detected if not specified) <code>--description</code> <code>-d</code> No Gateway description <code>--region</code> No AWS region (auto-detected from credentials)"},{"location":"user-guide/gateway/overview.html#examples","title":"Examples","text":""},{"location":"user-guide/gateway/overview.html#lambda-gateway-auto-detected","title":"Lambda Gateway (Auto-detected)","text":"<pre><code># Full command\nagentcore gateway \\\n  --name weather-gateway \\\n  --target arn:aws:lambda:us-west-2:123456789012:function:WeatherFunction \\\n  --execution-role WeatherExecutionRole\n\n# Short form\nagentcore gateway \\\n  -n weather-gateway \\\n  -t arn:aws:lambda:us-west-2:123456789012:function:WeatherFunction \\\n  -r WeatherExecutionRole\n</code></pre>"},{"location":"user-guide/gateway/overview.html#openapi-gateway","title":"OpenAPI Gateway","text":"<pre><code># From local file (auto-detected by .json extension)\nagentcore gateway \\\n  -n api-gateway \\\n  -t ./openapi.json \\\n  -r ApiExecutionRole\n\n# From S3 (auto-detected by s3:// prefix)\nagentcore gateway \\\n  -n s3-api-gateway \\\n  -t s3://my-bucket/openapi.json \\\n  -r ApiExecutionRole\n</code></pre>"},{"location":"user-guide/gateway/overview.html#with-explicit-type","title":"With Explicit Type","text":"<pre><code># Force Smithy type for a JSON file\nagentcore gateway \\\n  -n smithy-gateway \\\n  -t ./model.json \\\n  -r ExecutionRole \\\n  --type smithy\n</code></pre>"},{"location":"user-guide/gateway/overview.html#auto-detection-features","title":"Auto-Detection Features","text":"<p>The CLI automatically detects:</p>"},{"location":"user-guide/gateway/overview.html#region-and-account","title":"Region and Account","text":"<ul> <li>Uses AWS credentials to determine region</li> <li>Builds full role ARN from role name</li> </ul> <pre><code># These are equivalent (assuming account 123456789012 and region us-west-2):\n-r MyRole\n-r arn:aws:iam::123456789012:role/MyRole\n</code></pre>"},{"location":"user-guide/gateway/overview.html#target-type","title":"Target Type","text":"<p>Lambda: Detects from ARN pattern <code>arn:aws:lambda:*</code> S3: Detects from URI pattern <code>s3://</code> OpenAPI: Detects from file extensions <code>.json</code>, <code>.yaml</code>, <code>.yml</code></p>"},{"location":"user-guide/gateway/overview.html#output","title":"Output","text":"<p>The command returns: - Gateway ID - MCP Endpoint URL - OAuth Client Credentials</p> <p>Example output: <pre><code>Using region: us-west-2\nAuto-detected target type: lambda\nSetting up authentication for weather-gateway...\n\u2713 Created User Pool: us-west-2_ABC123\n\u2713 Created domain: bedrock-agentcore-abc123\n\u2713 Created resource server: weather-gateway\n\u2713 Created client: 1a2b3c4d5e\n\u2713 EZ Auth setup complete!\nCreating gateway weather-gateway...\n\u2713 Created Gateway: XYZ789\n\u2713 Gateway is ready\n\u2713 Added target successfully\n\n\u2705 Gateway setup complete!\nMCP Endpoint: &lt;fill&gt;\n\nOAuth Credentials:\nClient ID: 1a2b3c4d5e\nClient Secret: [hidden]\nScope: weather-gateway/invoke\n\nSave these credentials - you'll need them to get access tokens.\n</code></pre></p>"},{"location":"user-guide/gateway/overview.html#lambda-function-schema","title":"Lambda Function Schema","text":"<p>When creating a Lambda gateway without custom tools, the CLI auto-generates a default tool:</p> <pre><code>{\n  \"name\": \"invoke_function\",\n  \"description\": \"Invoke the Lambda function\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n  }\n}\n</code></pre> <p>To specify custom tools, create a Lambda configuration file:</p> <pre><code>{\n  \"arn\": \"arn:aws:lambda:us-west-2:123456789012:function:MyFunction\",\n  \"tools\": [\n    {\n      \"name\": \"process_data\",\n      \"description\": \"Process input data\",\n      \"inputSchema\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"input\": {\"type\": \"string\"}\n        },\n        \"required\": [\"input\"]\n      }\n    }\n  ]\n}\n</code></pre> <p>Then use it: <pre><code>agentcore gateway -n my-gateway -t lambda-config.json -r MyRole --type lambda\n</code></pre></p>"},{"location":"user-guide/gateway/overview.html#best-practices","title":"Best Practices","text":"<p>Use Role Names: Let the CLI build full ARNs Leverage Auto-detection: Omit <code>--type</code> when possible Save Credentials: Store OAuth credentials securely Use Short Forms: <code>-n</code>, <code>-t</code>, <code>-r</code> for faster commands</p>"},{"location":"user-guide/gateway/overview.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/gateway/overview.html#dns-propagation","title":"DNS Propagation","text":"<p>After creating a gateway, wait 60 seconds for Cognito domain DNS to propagate before requesting tokens.</p>"},{"location":"user-guide/gateway/overview.html#permission-errors","title":"Permission Errors","text":"<p>Ensure your execution role has: Trust relationship with Bedrock AgentCore service Permissions to invoke Lambda or read S3 Proper resource-based policies for cross-account access</p>"},{"location":"user-guide/gateway/overview.html#auto-detection-not-working","title":"Auto-detection Not Working","text":"<p>Explicitly specify <code>--type</code> if: File doesn't have standard extension Content type is ambiguous You want to override detection</p>"},{"location":"user-guide/gateway/quickstart.html","title":"Bedrock AgentCore Gateway","text":"<p>Bedrock AgentCore Gateway is a primitive within the Bedrock AgentCore SDK that enables you to: - Convert REST APIs (OpenAPI) into MCP tools - Expose Lambda functions as MCP tools - Handle authentication automatically with EZ Auth - Enable semantic search across your tools</p>"},{"location":"user-guide/gateway/quickstart.html#quick-start","title":"Quick Start","text":""},{"location":"user-guide/gateway/quickstart.html#using-the-cli-recommended","title":"Using the CLI (Recommended)","text":"<pre><code># Create a Gateway with Lambda target\nagentcore create_mcp_gateway \\\n  --name my-gateway \\\n  --target arn:aws:lambda:us-west-2:123:function:MyFunction \\\n  --execution-role arn:aws:iam::123:role/BedrockAgentCoreGatewayRole\n\n# Short form\nagentcore create_mcp_gateway \\\n  -n my-gateway \\\n  -t arn:aws:lambda:us-west-2:123:function:MyFunction \\\n  -r BedrockAgentCoreGatewayRole\n\n# Create a Gateway to use with targets defined in OpenAPI or Smithy\nagentcore create_mcp_gateway \\\n--region us-west-2 \\\n--name gateway-name\n\n# Create a Gateway Target with predefined smithy model\nagentcore create_mcp_gateway_target \\\n--region us-east-1 \\\n--gateway-arn arn:aws:bedrock-agentcore:us-east-1:123:gateway/gateway-id \\\n--gateway-url https://gateway-id.gateway.bedrock-agentcore.us-west-2.amazonaws.com/mcp \\\n--role-arn arn:aws:iam::123:role/BedrockAgentCoreGatewayRole \\\n--target-type smithyModel\n\n# Create a Gateway Target with OpenAPI target (OAuth with API Key)\nagentcore create_mcp_gateway_target \\\n--region us-east-1 \\\n--gateway-arn arn:aws:bedrock-agentcore:us-east-1:123:gateway/gateway-id \\\n--gateway-url https://gateway-id.gateway.bedrock-agentcore.us-west-2.amazonaws.com/mcp \\\n--role-arn arn:aws:iam::123:role/BedrockAgentCoreGatewayRole \\\n--target-type openApiSchema\n--credentials \"{\\\"api_key\\\": \\\"Bearer 123234bc\\\", \\\"credential_location\\\": \\\"HEADER\\\", \\\"credential_parameter_name\\\": \\\"Authorization\\\"}\" \\\n--target-payload \"{\\\"s3\\\": \\\"s3://mybucket/openApiSchema.json\\\"}}\"\n\n# Create a Gateway Target with OpenAPI target (OAuth with credential provider)\nagentcore create_mcp_gateway_target \\\n--region us-east-1 \\\n--gateway-arn arn:aws:bedrock-agentcore:us-east-1:123:gateway/gateway-id \\\n--gateway-url https://gateway-id.gateway.bedrock-agentcore.us-west-2.amazonaws.com/mcp \\\n--role-arn arn:aws:iam::123:role/BedrockAgentCoreGatewayRole \\\n--target-type openApiSchema\n--credentials \"{\\\"oauth2_provider_config\\\": { \\\"customOauth2ProviderConfig\\\": {\\\"oauthDiscovery\\\" : {\\\"authorizationServerMetadata\\\" : {\\\"issuer\\\" : \\\"&lt;issuer&gt;\\\",\\\"authorizationEndpoint\\\" : \\\"&lt;authorizationEndpoint&gt;\\\",\\\"tokenEndpoint\\\" : \\\"&lt;tokenEndpoint&gt;\\\"}},\\\"clientId\\\" : \\\"&lt;clientId&gt;\\\",\\\"clientSecret\\\" : \\\"&lt;clientSecret&gt;\\\" }}}\" \\\n--target-payload \"{\\\"s3\\\": \\\"s3://mybucket/openApiSchema.json\\\"}}\"\n</code></pre> <p>The CLI automatically: - Detects target type from ARN patterns or file extensions - Sets up Cognito OAuth (EZ Auth) - Detects your AWS region and account - Builds full role ARN from role name</p>"},{"location":"user-guide/gateway/quickstart.html#using-the-sdk","title":"Using the SDK","text":"<p>For programmatic access in scripts, notebooks, or CI/CD:</p> <pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\n\n# Initialize client\nclient = GatewayClient(region_name='us-west-2')\n\n# EZ Auth - automatically sets up Cognito OAuth\ncognito_result = client.create_oauth_authorizer_with_cognito(\"my-gateway\")\n\n# Create Gateway with Lambda target\ngateway = client.create_gateway(\n    name=\"my-gateway\",\n    roleArn=\"arn:aws:iam::123:role/BedrockAgentCoreGatewayExecutionRole\",\n    protocolType=\"MCP\",\n    authorizerType=\"CUSTOM_JWT\",\n    authorizerConfiguration={\n        \"customJWTAuthorizer\" : {\n            \"allowedClients\" : [ \"clientId\" ],\n            \"discoveryUrl\" : \"https://cognito-idp.us-west-2.amazonaws.com/mydomain/.well-known/openid-configuration\"\n        }\n    }\n)\nprint(f\"MCP Endpoint: {gateway.get_mcp_url()}\")\nprint(f\"OAuth Credentials:\")\nprint(f\"  Client ID: {cognito_result['client_info']['client_id']}\")\nprint(f\"  Client Secret: {cognito_result['client_info']['client_secret']}\")\nprint(f\"  Scope: {cognito_result['client_info']['scope']}\")\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#key-features","title":"Key Features","text":""},{"location":"user-guide/gateway/quickstart.html#ez-auth","title":"EZ Auth","text":"<p>Eliminates the complexity of OAuth setup: <pre><code># Without EZ Auth: 8+ manual steps\n# With EZ Auth: 1 line\ncognito_result = client.create_oauth_authorizer_with_cognito(\"my-gateway\")\n</code></pre></p>"},{"location":"user-guide/gateway/quickstart.html#semantic-search","title":"Semantic Search","text":"<p>Enable intelligent tool discovery: <pre><code>gateway = client.create_gateway(\n    name=\"my-gateway\",\n    roleArn=\"arn:aws:iam::123:role/BedrockAgentCoreGatewayExecutionRole\",\n    protocolType=\"MCP\",\n    authorizerType=\"CUSTOM_JWT\",\n    authorizerConfiguration={\n        \"customJWTAuthorizer\" : {\n            \"allowedClients\" : [ \"clientId\" ],\n            \"discoveryUrl\" : \"https://cognito-idp.us-west-2.amazonaws.com/mydomain/.well-known/openid-configuration\"\n        }\n    },\n    # Enable semantic search (default: True)\n    protocolConfiguration={\n        \"mcp\" : {\"searchType\" : \"SEMANTIC\"}\n    }\n)\n</code></pre></p>"},{"location":"user-guide/gateway/quickstart.html#multiple-target-types","title":"Multiple Target Types","text":""},{"location":"user-guide/gateway/quickstart.html#lambda-functions","title":"Lambda Functions","text":"<pre><code># Auto-generated schema (default)\ngateway = client.create_gateway(\n    name=\"my-gateway\",\n    roleArn=\"arn:aws:iam::123:role/BedrockAgentCoreGatewayExecutionRole\",\n    protocolType=\"MCP\",\n    authorizerType=\"CUSTOM_JWT\",\n    authorizerConfiguration={\n        \"customJWTAuthorizer\" : {\n            \"allowedClients\" : [ \"clientId\" ],\n            \"discoveryUrl\" : \"https://cognito-idp.us-west-2.amazonaws.com/mydomain/.well-known/openid-configuration\"\n        }\n    }\n)\n# Create a lambda target\nlambda_target = client.create_gateway_target(\n    name=\"my-gateway\",\n    gatewayIdentifier=\"gatewayIdentifier\",\n    description=\"description\",\n    credentialProviderConfigurations= [{\n      \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n    }],\n    targetConfiguration= {\n      \"mcp\": {\n        \"lambda\": {\n          \"lambdaArn\": \"arn:aws:lambda:us-west-2:123:function:MyFunction\",\n          \"toolSchema\": {\n              \"s3\": {\n                  \"uri\": \"s3&gt;//mybucket/spec.json\",\n                  \"bucketOwnerAccountId\": \"accountId\"\n              }\n          }\n        }\n      }\n    }\n)\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#openapi-rest-apis","title":"OpenAPI (REST APIs)","text":"<pre><code># Inline OpenAPI\nopenapi_spec = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"My API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"https://api.example.com\"}],\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"operationId\": \"listUsers\",\n                \"responses\": {\"200\": {\"description\": \"Success\"}}\n            }\n        }\n    }\n}\n\n# From S3\nopenAPI_target = client.create_gateway_target(\n    name=\"my-gateway\",\n    gatewayIdentifier=\"gatewayIdentifier\",\n    description=\"description\",\n    credentialProviderConfigurations= [{\n      \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n    }],\n    targetConfiguration= {\n      \"mcp\": {\n        \"openApiSchema\": {\n          \"s3\": \"s3&gt;//mybucket/spec.json\"\n        }\n      }\n    }\n)\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#mcp-integration","title":"MCP Integration","text":"<p>Once created, use any MCP client to interact with your Gateway:</p> <pre><code>import httpx\n\n# Get token\ntoken = client.get_access_token_for_cognito(cognito_result['client_info'])\n\n# List tools\nasync with httpx.AsyncClient() as http:\n    response = await http.post(\n        gateway.get_mcp_url(),\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"tools/list\",\n            \"params\": {}\n        }\n    )\n    tools = response.json()\n\n# Invoke a tool\nresponse = await http.post(\n    gateway.get_mcp_url(),\n    headers={\"Authorization\": f\"Bearer {token}\"},\n    json={\n        \"jsonrpc\": \"2.0\",\n        \"id\": 2,\n        \"method\": \"tools/call\",\n        \"params\": {\n            \"name\": \"listUsers\",\n            \"arguments\": {}\n        }\n    }\n)\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>AWS Account: Must be allowlisted for Bedrock AgentCore beta IAM Execution Role: With trust relationship to BedrockAgentCore service Permissions: Role needs access to your backends (Lambda invoke, S3 read, etc.) Custom Boto3 SDK: Download from Bedrock AgentCore documentation</p>"},{"location":"user-guide/gateway/quickstart.html#testing","title":"Testing","text":"<p>See <code>tests/bedrock_agentcore/gateway/</code> for integration tests covering all target types.</p>"},{"location":"user-guide/gateway/quickstart.html#api-reference","title":"API Reference","text":""},{"location":"user-guide/gateway/quickstart.html#gatewayclient","title":"GatewayClient","text":"<ul> <li><code>create_oauth_authorizer_with_cognito(gateway_name)</code> - Set up Cognito OAuth automatically</li> <li><code>setup_gateway(...)</code> - Create gateway with target in one call</li> <li><code>get_test_token_for_cognito(client_info)</code> - Get OAuth token for testing</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#gateway-resource","title":"Gateway Resource","text":"<ul> <li><code>id</code> - Gateway identifier</li> <li><code>get_mcp_url()</code> - Get the MCP endpoint URL</li> <li><code>wait_until_ready()</code> - Wait for gateway to be ready</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#list-of-all-builtin-schemas","title":"List of all builtin schemas","text":"<pre><code>1. confluence\n2. onedrive\n3. dynamodb\n4. cloudwatch\n5. slack\n6. smartsheet\n7. sap-business-partner\n8. tavily\n9. jira\n10. sap-product-master-data\n11. genericHTTP\n12. sap-material-stock\n13. sap-physical-inventory\n14. salesforce\n15. servicenow\n16. bambooHR\n17. brave-search\n18. msExchange\n19. sap-bill-of-material\n20. sharepoint\n21. asana\n22. zendesk\n23. msTeams\n24. pagerduty\n25. zoom\n26. bedrock-runtime\n27. bedrock-agent-runtime\n</code></pre>"},{"location":"user-guide/identity/quickstart.html","title":"Getting Started with AgentCore Identity","text":"<p>Amazon Bedrock AgentCore Identity provides a secure way to manage identities for your AI agents and enable authenticated access to external services. This guide will help you get started with implementing identity features in your agent applications.</p>"},{"location":"user-guide/identity/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> <li>AWS CLI configured with your credentials</li> <li>(Optional) External service accounts for OAuth2 or API key integration</li> </ul>"},{"location":"user-guide/identity/quickstart.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#create-a-workload-identity","title":"Create a Workload Identity","text":"<p>A workload identity is a unique identifier that represents your agent within the AgentCore Identity system:</p> <pre><code>from bedrock_agentcore.services.identity import IdentityClient\n\n# Create identity client\nidentity_client = IdentityClient(\"us-east-1\")\n\n# Create workload identity\nworkload_identity = identity_client.create_workload_identity(\n    name=\"my-research-agent\",\n)\n\nprint(f\"Workload Identity ARN: {workload_identity['workloadIdentityArn']}\")\nprint(f\"Agent Name: {workload_identity['name']}\")\n</code></pre> <p>You can also use the AWS CLI:</p> <pre><code>aws bedrock-agentcore create-workload-identity \\\n    --name \"my-research-agent\"\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#configure-credential-providers","title":"Configure Credential Providers","text":"<p>Credential providers define how your agent accesses external services:</p>"},{"location":"user-guide/identity/quickstart.html#oauth2-provider-example-google","title":"OAuth2 Provider Example (Google)","text":"<pre><code># Configure Google OAuth2 provider\ngoogle_provider = identity_client.create_oauth2_credential_provider(req={\n    \"name\": \"myGoogleCredentialProvider\",\n    \"credentialProviderVendor\": \"GoogleOauth2\",\n    \"oauth2ProviderConfigInput\": {\n        \"googleOauth2ProviderConfig\": {\n            \"clientId\": \"your-google-client-id\",\n            \"clientSecret\": \"your-google-client-secret\"\n        }\n    }\n})\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#api-key-provider-example-perplexity-ai","title":"API Key Provider Example (Perplexity AI)","text":"<pre><code># Configure API key provider\nperplexity_provider = identity_client.create_api_key_credential_provider(req={\n    \"name\": \"myPerplexityAPIKeyCredentialProvider\",\n    \"apiKey\": \"myApiKey\"\n})\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#configure-environment-variables","title":"Configure Environment Variables","text":"<p>Set up environment variables for your development environment:</p> <pre><code># AWS Configuration\nexport AWS_REGION=us-west-2\nexport AWS_ACCESS_KEY_ID=your-access-key-id\nexport AWS_SECRET_ACCESS_KEY=your-secret-access-key\n\n# Agent Configuration\nexport AGENT_IDENTITY_ID=your-agent-identity-id\nexport AGENT_IDENTITY_ARN=your-agent-identity-arn\nexport WORKLOAD_ACCESS_TOKEN=your-workload-access-token\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#building-a-simple-research-agent","title":"Building a Simple Research Agent","text":"<p>Let's create a simple research agent that demonstrates AgentCore Identity capabilities:</p>"},{"location":"user-guide/identity/quickstart.html#agent-implementation","title":"Agent Implementation","text":"<p>Create a file named <code>research_agent.py</code>:</p> <pre><code># research_agent.py\nimport os\nimport asyncio\nfrom typing import Optional\nfrom datetime import datetime\nfrom bedrock_agentcore.services.identity import IdentityClient\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nimport requests\n\nclass ResearchAgent:\n    def __init__(self):\n        self.identity_client = IdentityClient(\"us-east-1\")\n        self.workload_token = os.getenv('WORKLOAD_ACCESS_TOKEN')\n\n    async def search_web(self, query: str) -&gt; str:\n        \"\"\"Search the web using Perplexity AI\"\"\"\n        # Get API key from identity service\n        api_key = await self.identity_client.get_api_key(\n            provider_name=\"myPerplexityAPIKeyCredentialProvider\",\n            agent_identity_token=self.workload_token\n        )\n\n        url = \"https://api.perplexity.ai/chat/completions\"\n        headers = {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        body = {\n            \"model\": \"sonar\",\n            \"messages\": [\n                {\"role\": \"user\", \"content\": query}\n            ]\n        }\n\n        try:\n            response = requests.post(url, headers=headers, json=body)\n            response.raise_for_status()\n            result = response.json()\n            return result[\"choices\"][0][\"message\"][\"content\"]\n        except Exception as e:\n            return f\"Search error: {str(e)}\"\n\n    async def save_to_drive(self, content: str, filename: str) -&gt; str:\n        \"\"\"Save content to Google Drive\"\"\"\n        try:\n            # Get OAuth2 access token from identity service\n            access_token = await self.identity_client.get_token(\n                provider_name=\"myGoogleCredentialProvider\",\n                scopes=[\"https://www.googleapis.com/auth/drive.file\"],\n                agent_identity_token=self.workload_token,\n                auth_flow=\"USER_FEDERATION\",\n                callback_url=\"https://myapp.com/callback\"\n            )\n\n            # Create Google Drive service\n            creds = Credentials(token=access_token)\n            service = build(\"drive\", \"v3\", credentials=creds)\n\n            # Create file metadata\n            file_metadata = {\n                'name': filename,\n                'mimeType': 'text/plain'\n            }\n\n            # Upload file\n            from googleapiclient.http import MediaIoBaseUpload\n            import io\n\n            media = MediaIoBaseUpload(\n                io.BytesIO(content.encode('utf-8')),\n                mimetype='text/plain'\n            )\n\n            file = service.files().create(\n                body=file_metadata,\n                media_body=media,\n                fields='id,name,webViewLink'\n            ).execute()\n\n            return f\"File saved to Google Drive: {file.get('webViewLink')}\"\n\n        except Exception as e:\n            return f\"Drive save error: {str(e)}\"\n\n    async def research_and_save(self, topic: str, user_id: str = None) -&gt; str:\n        \"\"\"Main agent function: research a topic and save to Drive\"\"\"\n        try:\n            # Search for information\n            search_query = f\"Research comprehensive information about: {topic}\"\n            search_results = await self.search_web(search_query)\n\n            # Format the research report\n            report = f\"\"\"\nResearch Report: {topic}\nGenerated by Research Agent\n{'=' * 50}\n\n{search_results}\n\n{'=' * 50}\nReport generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n            \"\"\"\n\n            # Save to Google Drive\n            filename = f\"research_report_{topic.replace(' ', '_')}.txt\"\n\n            save_result = await self.save_to_drive(\n                content=report,\n                filename=filename\n            )\n\n            return f\"Research completed! {save_result}\"\n\n        except Exception as e:\n            return f\"Research failed: {str(e)}\"\n\n# Create agent instance\nagent = ResearchAgent()\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#create-http-server","title":"Create HTTP Server","text":"<p>Create a file named <code>server.py</code> to host your agent:</p> <pre><code># server.py\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport uvicorn\nfrom research_agent import agent\n\napp = FastAPI(title=\"Research Agent API\")\n\nclass ResearchRequest(BaseModel):\n    topic: str\n    user_id: Optional[str] = None\n\n@app.post(\"/research\")\nasync def research_endpoint(request: ResearchRequest):\n    \"\"\"Research a topic and save results to Google Drive\"\"\"\n    try:\n        result = await agent.research_and_save(\n            topic=request.topic,\n            user_id=request.user_id\n        )\n        return {\"status\": \"success\", \"message\": result}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\"}\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8080)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#test-your-agent","title":"Test Your Agent","text":"<p>Start your agent server:</p> <pre><code>python server.py\n</code></pre> <p>Test the agent using curl:</p> <pre><code># Test health endpoint\ncurl http://localhost:8080/health\n\n# Test research functionality\ncurl -X POST http://localhost:8080/research \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"topic\": \"artificial intelligence trends 2024\",\n        \"user_id\": \"user123\"\n    }'\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#understanding-the-oauth2-authorization-flow","title":"Understanding the OAuth2 Authorization Flow","text":"<p>When your agent first attempts to access Google Drive, it will trigger a 3-legged OAuth (3LO) flow:</p> <ol> <li>The AgentCore SDK will display a URL for authentication</li> <li>The user visits the URL and grants permissions</li> <li>The token is securely stored in the token vault</li> <li>Subsequent requests use the cached token</li> </ol> <p>Example output during the OAuth2 flow:</p> <pre><code>Waiting for authentication...\nVisit the following URL to login:\nhttps://bedrock-agentcore.us-west-2.amazonaws.com/identities/oauth2/authorize?request_uri=123456789\n\nPolling for token... (press Ctrl+C to cancel)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#using-declarative-annotations","title":"Using Declarative Annotations","text":"<p>For a cleaner implementation, you can use AgentCore Identity's declarative annotations:</p> <pre><code>from bedrock_agentcore.identity import requires_access_token, requires_api_key\n\n@requires_api_key(provider=\"Perplexity AI\")\ndef search_perplexity(query, api_key=None):\n    \"\"\"\n    Search Perplexity AI with the query.\n    The api_key is automatically injected by the @requires_api_key decorator.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    # Make API call to Perplexity AI with the headers\n    # ...\n    return results\n\n@requires_access_token(provider=\"Google Workspace\", scopes=[\"https://www.googleapis.com/auth/drive.file\"])\ndef save_to_google_drive(content, filename, access_token=None):\n    \"\"\"\n    Save content to Google Drive.\n    The access_token is automatically injected by the @requires_access_token decorator.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    # Make API call to Google Drive with the headers\n    # ...\n    return results\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#security-best-practices","title":"Security Best Practices","text":"<p>When working with identity information:</p> <ol> <li>Never hardcode credentials in your agent code</li> <li>Use environment variables or AWS Secrets Manager for sensitive information</li> <li>Apply least privilege principle when configuring IAM permissions</li> <li>Regularly rotate credentials for external services</li> <li>Audit access logs to monitor agent activity</li> <li>Implement proper error handling for authentication failures</li> </ol>"},{"location":"user-guide/memory/quickstart.html","title":"Getting Started with AgentCore Memory","text":"<p>Amazon Bedrock AgentCore Memory lets you create and manage memory resources that store conversation context for your AI agents. This section guides you through installing dependencies and implementing both short-term and long-term memory features.</p>"},{"location":"user-guide/memory/quickstart.html#install-dependencies","title":"Install Dependencies","text":"<p>To get started with Amazon Bedrock AgentCore Memory, install the required Python package:</p> <pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-memory","title":"Create Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-memory-for-short-term-memory","title":"Create Memory for Short-term Memory","text":"<p>Adding short-term memory is a quick, one-time setup process. Short-term memory maintains context without persisting historical data. This is useful for tracking current conversation flow, such as customer support interactions. Note that for short-term memory, you don't need to add a memory strategy which is used to extract memories for long-term storage.</p> <pre><code>from bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\n\nmemory = client.create_memory(\n    name=\"CustomerSupportAgentMemory\",\n    description=\"Memory for customer support conversations\",\n)\n\n# The memory_id will be used in following operations\nprint(f\"Memory ID: {memory.get('id')}\")\nprint(f\"Memory: {memory}\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#list-existing-memory-resources","title":"List Existing Memory Resources","text":"<p>If you already have existing memory resources created in Amazon Bedrock AgentCore Memory, you can list them to find their identifiers:</p> <pre><code>for memory in client.list_memories():\n    print(f\"Memory Arn: {memory.get('arn')}\")\n    print(f\"Memory ID: {memory.get('id')}\")\n    print(\"--------------------------------------------------------------------\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#maintain-user-context-using-short-term-memory","title":"Maintain User Context Using Short-term Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-events-in-short-term-memory","title":"Create Events in Short-term Memory","text":"<p>The create_event action stores agent interactions into short-term memory instantly. You can save conversations either one turn at a time or in batches, depending on your application needs. Each saved interaction can include user messages, assistant responses, and tool actions. The process is synchronous, ensuring no conversation data is lost.</p> <pre><code>client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"OrderSupportSession1\", #Unique id for a particular request/conversation.\n    messages=[\n        (\"Hi, I'm having trouble with my order #12345\", \"USER\"),\n        (\"I'm sorry to hear that. Let me look up your order.\", \"ASSISTANT\"),\n        (\"lookup_order(order_id='12345')\", \"TOOL\"),\n        (\"I see your order was shipped 3 days ago. What specific issue are you experiencing?\", \"ASSISTANT\"),\n        (\"Actually, before that - I also want to change my email address\", \"USER\"),\n        (\n            \"Of course! I can help with both. Let's start with updating your email. What's your new email?\",\n            \"ASSISTANT\",\n        ),\n        (\"newemail@example.com\", \"USER\"),\n        (\"update_customer_email(old='old@example.com', new='newemail@example.com')\", \"TOOL\"),\n        (\"Email updated successfully! Now, about your order issue?\", \"ASSISTANT\"),\n        (\"The package arrived damaged\", \"USER\"),\n    ],\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#load-conversations-from-short-term-memory","title":"Load Conversations from Short-term Memory","text":"<p>The list_events method loads conversations from short-term memory using the memory_id, actor_id and session_id. The process is synchronous and returns the conversation data:</p> <pre><code>conversations = client.list_events(\n    memory_id=memory.get(\"id\"),\n    actor_id=\"User84\",\n    session_id=\"OrderSupportSession1\",\n    max_results=5,\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#long-term-memory","title":"Long-term Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-memory-with-long-term-memory","title":"Create Memory with Long-term Memory","text":"<p>With long-term memory, you can extract and store information from conversations for future use. When you add long-term memory, you can use one of the following strategies:</p> <ul> <li> <p>User Preferences (UserPreferenceMemoryStrategy): Stores and learns recurring patterns in user behavior, interaction styles, and choices. This enables the agent to automatically adapt its responses to match user preferences across multiple sessions.</p> </li> <li> <p>Semantic Facts (SemanticMemoryStrategy): Maintains knowledge of facts and domain-specific information, technical concepts, and their relationships. This allows the agent to provide informed responses based on previously established context and understanding.</p> </li> <li> <p>Session Summaries (SummaryMemoryStrategy): Creates condensed representations of interaction content and outcomes. These summaries provide quick reference points for past activities and help optimize context window usage for future interactions.</p> </li> </ul> <p>To create a memory resource with long-term memory, use the create_memory_and_wait method with a strategy. When you add a memory strategy for the first time to a memory resource (either on create or update), it may take 2-3 minutes for it to become ACTIVE:</p> <pre><code>memory = client.create_memory_and_wait(\n    name=\"MyAgentMemory\",\n    strategies=[{\n        \"summaryMemoryStrategy\": {\n            # Name of the extraction model/strategy\n            \"name\": \"SessionSummarizer\",\n            # Organize facts by session ID for easy retrieval\n            # Example: \"summaries/User84/session123\" contains summary of session123\n            \"namespaces\": [\"/summaries/{actorId}/{sessionId}\"]\n        }\n    }]\n)\n</code></pre> <p>If you are already using short-term memory, you can upgrade to use long-term memory by adding a strategy to the existing memory resource:</p> <pre><code>summary_strategy = client.add_summary_strategy(\n    memory_id = memory.get(\"id\"),\n    name=\"SessionSummarizer\",\n    description=\"Summarizes conversation sessions\",\n    namespaces=[\"/summaries/{actorId}/{sessionId}\"] #Namespace allow you to organize all extracted information. This template will extract information for each sessionId belonging to an actor in separate namespace\n)\n</code></pre> <p>Note</p> <p>Long-term memory records will only be extracted from events that are stored after the newly added strategies become ACTIVE. Conversations stored before a strategy is added will not appear in long-term memory.</p>"},{"location":"user-guide/memory/quickstart.html#save-conversations-and-view-extracted-memories","title":"Save Conversations and View Extracted Memories","text":"<p>The following example demonstrates how to save a conversation and retrieve its automatically extracted memories. After saving the conversation, we wait for 1 minute to allow the long-term memory strategies to process and extract meaningful information before retrieving it.</p> <pre><code>import time\n\nevent = client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"OrderSupportSession1\",\n    messages=[\n        (\"Hi, I'm having trouble with my order #12345\", \"USER\"),\n        (\"I'm sorry to hear that. Let me look up your order.\", \"ASSISTANT\"),\n        (\"lookup_order(order_id='12345')\", \"TOOL\"),\n        (\"I see your order was shipped 3 days ago. What specific issue are you experiencing?\", \"ASSISTANT\"),\n        (\"Actually, before that - I also want to change my email address\", \"USER\"),\n        (\n            \"Of course! I can help with both. Let's start with updating your email. What's your new email?\",\n            \"ASSISTANT\",\n        ),\n        (\"newemail@example.com\", \"USER\"),\n        (\"update_customer_email(old='old@example.com', new='newemail@example.com')\", \"TOOL\"),\n        (\"Email updated successfully! Now, about your order issue?\", \"ASSISTANT\"),\n        (\"The package arrived damaged\", \"USER\"),\n    ],\n)\n\n# Wait for meaningful memories to be extracted from the conversation.\ntime.sleep(60)\n\n# We will query for the summary of the issue using the namespace set in summary strategy above\nmemories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/summaries/User84/OrderSupportSession1\",\n    query=\"can you summarize the support issue\"\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#use-long-term-memory-in-an-agent","title":"Use Long-term Memory in an Agent","text":""},{"location":"user-guide/memory/quickstart.html#install-dependencies_1","title":"Install Dependencies","text":"<pre><code>pip install strands\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#add-memory-to-an-agent","title":"Add Memory to an Agent","text":"<pre><code>from strands import tool, Agent\nfrom strands_tools.agent_core_memory import AgentCoreMemoryToolProvider\nimport time\nfrom bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\nmemory = client.create_memory_and_wait(\n    name=\"MyAgentMemory\",\n    strategies=[{\n        \"userPreferenceMemoryStrategy\": {\n            \"name\": \"UserPreference\",\n            \"namespaces\": [\"/users/{actorId}\"]\n        }\n    }]\n)\n\nstrands_provider = AgentCoreMemoryToolProvider(\n    memory_id=memory.get(\"id\"),\n    actor_id=\"CaliforniaPerson\",\n    session_id=\"TalkingAboutFood\",\n    namespace=\"/users/CaliforniaPerson\",\n    region=\"us-west-2\"\n)\nagent = Agent(tools=strands_provider.tools)\n\nagent(\"Im vegetarian and I prefer restaurants with a quiet atmosphere.\")\nagent(\"Im in the mood for Italian cuisine.\")\nagent(\"Id prefer something mid-range and located downtown.\")\nagent(\"I live in Irvine.\")\n\ntime.sleep(60)\n\n# This will use the long-term memory tool\nagent(\"I dont remember what I was in a mood for, do you remember?\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#custom-strategies","title":"Custom Strategies","text":"<p>You can customize existing strategies by specifying your own prompt. This allows you to specify the exact information you want to extract. In the example below, we will create a custom prompt to extract a user's preference about their airline needs.</p>"},{"location":"user-guide/memory/quickstart.html#create-an-iam-role-for-the-service","title":"Create an IAM Role for the Service","text":"<p>Start by ensuring you have an IAM role with the managed policy <code>AmazonBedrockAgentCoreMemoryBedrockModelInferenceExecutionRolePolicy</code>, or create a policy with the following permissions:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:*::foundation-model/*\",\n                \"arn:aws:bedrock:*:*:inference-profile/*\"\n            ],\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"aws:ResourceAccount\": \"${aws:PrincipalAccount}\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>This role is assumed by the Service to call the model in your AWS account. Use the trust policy below when creating the role or when using the managed policy:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": [\n                    \"bedrock-agentcore.amazonaws.com\"\n                ]\n            },\n            \"Action\": \"sts:AssumeRole\"\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-a-long-term-memory-with-a-custom-strategy","title":"Create a Long-term Memory with a Custom Strategy","text":"<pre><code>from bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\n\n# Our custom prompt ensures that we're able to extract a customer's travel preferences.\nCUSTOM_PROMPT = \"\"\"\\\nYou are tasked with analyzing conversations to extract the user's preferences. You'll be analyzing two sets of data:\n\n&lt;past_conversation&gt;\n[Past conversations between the user and system will be placed here for context]\n&lt;/past_conversation&gt;\n\n&lt;current_conversation&gt;\n[The current conversation between the user and system will be placed here]\n&lt;/current_conversation&gt;\n\nYour job is to identify and categorize the user's preferences about their travel habits.\n- Extract a user's preference for the airline carrier from the choice they make.\n- Extract a user's preference for the seat type on the airline from the choice they make. It can aisle, middle or window\n\"\"\"\n\n# Replace the value with the role arn created above.\nMEMORY_EXECUTION_ROLE_ARN = \"arn:aws:iam::123456789012:role/MyRole\"\n\nmemory = client.create_memory_and_wait(\n    name=\"AirlineMemoryAgent\",\n    strategies=[{\n        \"customMemoryStrategy\": {\n            \"name\": \"UserPreference\",\n            \"namespaces\": [\"/users/{actorId}\"],\n            \"configuration\" : {\n                \"userPreferenceOverride\" : {\n                    \"extraction\" : {\n                        \"modelId\" : \"anthropic.claude-3-5-sonnet-20241022-v2:0\",\n                        \"appendToPrompt\": CUSTOM_PROMPT\n                    }\n                }\n            }\n        }\n    }],\n    memory_execution_role_arn=MEMORY_EXECUTION_ROLE_ARN\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-events-to-upload-user-conversations","title":"Create Events to Upload User Conversations","text":"<pre><code>event = client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"AirlineBookingSession1\",\n    messages=[\n        (\"Hi, I would like to book a flight from Seattle to New York for this Sunday\", \"USER\"),\n        (\"Certainly, let me try to find the best flights for you\", \"ASSISTANT\"),\n        (\"flight_search(start='Seattle', end='New York', date='2025-07-30')\", \"TOOL\"),\n        (\"I have a two options available. 1/ Delta Airlines DL456 at 10:30 AM 2/ American Airline AA345 at 4PM. \", \"ASSISTANT\"),\n        (\"Delta airline\", \"USER\"),\n        (\"Sure. I will get you a seat on Delta flight DL456. Do you have a preference for a seat type\",\"ASSISTANT\",),\n        (\"Yes. Window please\", \"USER\"),\n        (\"I have booked you on flight DL456 at 10:30 AM on 07/30/2025. Your seat number is 26A. You will more details in your email\", \"ASSISTANT\"),\n    ],\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#search-for-users-preferences","title":"Search for User's Preferences","text":"<pre><code>memories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/users/User84\",\n    query=\"What are the user's preferences for airline type ?\"\n)\n\nmemories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/users/User84\",\n    query=\"What are the user's preferences for seat type ?\"\n)\n</code></pre>"},{"location":"user-guide/observability/quickstart.html","title":"Getting Started with Observability","text":"<p>Amazon Bedrock AgentCore Observability helps you trace, debug, and monitor agent performance in production environments. This guide will help you get started with implementing observability features in your agent applications.</p>"},{"location":"user-guide/observability/quickstart.html#what-is-agentcore-observability","title":"What is AgentCore Observability?","text":"<p>AgentCore Observability provides:</p> <ul> <li>Detailed visualizations of each step in the agent workflow</li> <li>Real-time visibility into operational performance through CloudWatch dashboards</li> <li>Telemetry for key metrics such as session count, latency, duration, token usage, and error rates</li> <li>Rich metadata tagging and filtering for issue investigation</li> <li>Standardized OpenTelemetry (OTEL)-compatible format for easy integration with existing monitoring stacks</li> </ul>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-agentcore-hosted-agents","title":"Enabling Observability for AgentCore-Hosted Agents","text":"<p>By default, agents deployed to the AgentCore runtime automatically has Observability enabled.</p>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-non-agentcore-hosted-agents","title":"Enabling Observability for Non-AgentCore-Hosted Agents","text":"<p>For agents running outside of the AgentCore runtime, follow these additional steps:</p>"},{"location":"user-guide/observability/quickstart.html#step-1-configure-aws-environment-variables","title":"Step 1: Configure AWS Environment Variables","text":"<pre><code>export AWS_ACCOUNT_ID=&lt;account id&gt;\nexport AWS_DEFAULT_REGION=&lt;default region&gt;\nexport AWS_REGION=&lt;region&gt;\nexport AWS_ACCESS_KEY_ID=&lt;access key id&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secret key&gt;\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-2-configure-opentelemetry-environment-variables","title":"Step 2: Configure OpenTelemetry Environment Variables","text":"<pre><code>export AGENT_OBSERVABILITY_ENABLED=true\nexport OTEL_PYTHON_DISTRO=aws_distro\nexport OTEL_PYTHON_CONFIGURATOR=aws_configurator\nexport OTEL_RESOURCE_ATTRIBUTES=service.name=&lt;agent-name&gt;,aws.log.group.names=/aws/bedrock-agentcore/runtimes/&lt;agent-id&gt;,cloud.resource_id=&lt;AgentEndpointArn:AgentEndpointName&gt;\nexport OTEL_EXPORTER_OTLP_LOGS_HEADERS=x-aws-log-group=/aws/bedrock-agentcore/runtimes/&lt;agent-id&gt;,x-aws-log-stream=runtime-logs,x-aws-metric-namespace=bedrock-agentcore\nexport OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf\nexport OTEL_TRACES_EXPORTER=otlp\n</code></pre> <p>Replace <code>&lt;agent-name&gt;</code> with your agent's name and <code>&lt;agent-id&gt;</code> with a unique identifier for your agent.</p>"},{"location":"user-guide/observability/quickstart.html#step-3-propagate-session-id-in-otel-baggage","title":"Step 3: Propagate Session ID in OTEL Baggage","text":"<pre><code>from opentelemetry import baggage\n\nctx = baggage.set_baggage(\"session.id\", session_id)  # Set the session.id in baggage\nattach(ctx)  # Attach the context to make it active\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#viewing-observability-data","title":"Viewing Observability Data","text":"<p>After implementing observability, you can view the collected data in CloudWatch:</p>"},{"location":"user-guide/observability/quickstart.html#view-logs-in-cloudwatch","title":"View Logs in CloudWatch","text":"<ol> <li>Open the CloudWatch console</li> <li>In the left navigation pane, expand Logs and select Log groups</li> <li>Search for your agent's log group:</li> <li>Standard logs (stdout/stderr): <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/[runtime-logs] &lt;UUID&gt;</code></li> <li>OTEL structured logs: <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/runtime-logs</code></li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-traces-and-spans","title":"View Traces and Spans","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Transaction Search from the left navigation</li> <li>Filter by service name or other criteria</li> <li>Select a trace to view the detailed execution graph</li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-metrics","title":"View Metrics","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Metrics from the left navigation</li> <li>Browse to the <code>bedrock-agentcore</code> namespace</li> <li>Explore the available metrics</li> </ol>"},{"location":"user-guide/observability/quickstart.html#best-practices","title":"Best Practices","text":"<ol> <li>Use consistent session IDs - Reuse the same session ID for related requests to maintain context across interactions</li> <li>Implement distributed tracing - Use the provided headers to enable end-to-end tracing across your application components</li> <li>Add custom attributes - Enhance your traces and metrics with custom attributes for better troubleshooting</li> <li>Monitor resource usage - Pay attention to memory usage metrics to optimize your agent's performance</li> <li>Set up alerts - Configure CloudWatch alarms to notify you of potential issues before they impact users</li> </ol>"},{"location":"user-guide/runtime/async.html","title":"Handle Asynchronous and Long Running Agents","text":"<p>AgentCore Runtime can handle asynchronous processing and long running agents. Asynchronous tasks allow your agent to continue processing after responding to the client and handle long-running operations without blocking responses.</p> <p>With async processing, your agent can:</p> <ul> <li>Start a task that might take minutes or hours</li> <li>Immediately respond to the user saying \"I've started working on this\"</li> <li>Continue processing in the background</li> <li>Allow the user to check back later for results</li> </ul>"},{"location":"user-guide/runtime/async.html#key-concepts","title":"Key Concepts","text":""},{"location":"user-guide/runtime/async.html#asynchronous-processing-model","title":"Asynchronous Processing Model","text":"<p>The Amazon Bedrock AgentCore SDK supports both synchronous and asynchronous processing through a unified API. This creates a flexible implementation pattern for both clients and agent developers. Agent clients can work with the same API without differentiating between synchronous and asynchronous on the client side. With the ability to invoke the same session across invocations, agent developers can reuse context and build upon this context incrementally without implementing complex task management logic.</p>"},{"location":"user-guide/runtime/async.html#runtime-session-lifecycle-management","title":"Runtime Session Lifecycle Management","text":"<p>Agent code communicates its processing status using the \"/ping\" health status:</p> <ul> <li>\"Healthy\": Ready for new work, no background tasks running</li> <li>\"HealthyBusy\": Currently processing background tasks</li> </ul> <p>A session in idle state for 15 minutes gets automatically terminated.</p>"},{"location":"user-guide/runtime/async.html#three-ways-to-manage-async-tasks","title":"Three Ways to Manage Async Tasks","text":""},{"location":"user-guide/runtime/async.html#1-async-task-decorator-recommended","title":"1. Async Task Decorator (Recommended)","text":"<p>The simplest way to track asynchronous functions. The SDK automatically manages the ping status:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.async_task\nasync def background_work():\n    await asyncio.sleep(10)  # Status becomes \"HealthyBusy\"\n    return \"done\"\n\n@app.entrypoint\nasync def handler(event):\n    asyncio.create_task(background_work())\n    return {\"status\": \"started\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>How it works: - The <code>@app.async_task</code> decorator tracks function execution - When the function runs, ping status changes to \"HealthyBusy\" - When the function completes, status returns to \"Healthy\"</p>"},{"location":"user-guide/runtime/async.html#2-manual-task-management","title":"2. Manual Task Management","text":"<p>For more control over task tracking, use the API methods directly:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nimport threading\nimport time\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(event):\n    \"\"\"Start tracking a task manually\"\"\"\n    # Start tracking the task\n    task_id = app.add_async_task(\"data_processing\", {\"batch\": 100})\n\n    # Start background work\n    def background_work():\n        time.sleep(30)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n\n    return {\"status\": \"Task started\", \"task_id\": task_id}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>API Methods: - <code>app.add_async_task(name, metadata)</code> - Start tracking a task - <code>app.complete_async_task(task_id)</code> - Mark task as complete - <code>app.get_async_task_info()</code> - Get information about running tasks</p>"},{"location":"user-guide/runtime/async.html#3-custom-ping-handler","title":"3. Custom Ping Handler","text":"<p>Override automatic status with custom logic:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom bedrock_agentcore.runtime.models import PingStatus\n\napp = BedrockAgentCoreApp()\n\n# Global state to track custom conditions\nprocessing_data = False\n\n@app.ping\ndef custom_status():\n    \"\"\"Custom ping handler with your own logic\"\"\"\n    if processing_data or system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n\n@app.entrypoint\ndef handler(event):\n    global processing_data\n\n    if event.get(\"action\") == \"start_processing\":\n        processing_data = True\n        # Start your processing...\n        return {\"status\": \"Processing started\"}\n\n    return {\"status\": \"Ready\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/runtime/async.html#complete-example-with-strands","title":"Complete Example with Strands","text":"<p>Here's a practical example combining async tasks with the Strands AI framework:</p> <pre><code>import threading\nimport time\nfrom strands import Agent, tool\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize app with debug mode for task management\napp = BedrockAgentCoreApp(debug=True)\n\n@tool\ndef start_background_task(duration: int = 5) -&gt; str:\n    \"\"\"Start a simple background task that runs for specified duration.\"\"\"\n    # Start tracking the async task\n    task_id = app.add_async_task(\"background_processing\", {\"duration\": duration})\n\n    # Run task in background thread\n    def background_work():\n        time.sleep(duration)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return f\"Started background task (ID: {task_id}) for {duration} seconds. Agent status is now BUSY.\"\n\n# Create agent with the tool\nagent = Agent(tools=[start_background_task])\n\n@app.entrypoint\ndef main(payload):\n    \"\"\"Main entrypoint - handles user messages.\"\"\"\n    user_message = payload.get(\"prompt\", \"Try: start_background_task(3)\")\n    return {\"message\": agent(user_message).message}\n\nif __name__ == \"__main__\":\n    print(\"\ud83d\ude80 Simple Async Strands Example\")\n    print(\"Test: curl -X POST http://localhost:8080/invocations -H 'Content-Type: application/json' -d '{\\\"prompt\\\": \\\"start a 3 second task\\\"}'\")\n    app.run()\n</code></pre> <p>This example demonstrates: - Creating a background task that runs asynchronously - Tracking the task's status with <code>add_async_task</code> and <code>complete_async_task</code> - Responding immediately to the user while processing continues - Managing the agent's health status automatically</p>"},{"location":"user-guide/runtime/async.html#ping-status-priority","title":"Ping Status Priority","text":"<p>The ping status is determined in this priority order:</p> <ol> <li>Forced Status (debug actions like <code>force_busy</code>)</li> <li>Custom Handler (<code>@app.ping</code> decorator)</li> <li>Automatic (based on active <code>@app.async_task</code> functions)</li> </ol>"},{"location":"user-guide/runtime/async.html#debug-and-testing-features","title":"Debug and Testing Features","text":"<p>Enable debug mode for additional testing capabilities:</p> <pre><code>app = BedrockAgentCoreApp(debug=True)\n</code></pre> <p>Debug Actions (via POST with <code>\"_agent_core_app_action\"</code>): - <code>\"ping_status\"</code> - Check current status - <code>\"job_status\"</code> - List running tasks - <code>\"force_busy\"</code> / <code>\"force_healthy\"</code> - Force status - <code>\"clear_forced_status\"</code> - Clear forced status</p> <p>API Methods: <pre><code>task_id = app.add_async_task(\"task_name\", metadata={})\nsuccess = app.complete_async_task(task_id)\nstatus = app.get_current_ping_status()\ninfo = app.get_async_task_info()\n</code></pre></p>"},{"location":"user-guide/runtime/async.html#testing-your-async-agent","title":"Testing Your Async Agent","text":""},{"location":"user-guide/runtime/async.html#local-testing-with-curl","title":"Local Testing with curl","text":"<pre><code># Start your agent\npython my_async_agent.py\n\n# Test ping endpoint\ncurl http://localhost:8080/ping\n\n# Start a background task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"start a background task\"}'\n\n# Check if status changed to HealthyBusy\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#local-testing-with-agentcore-cli","title":"Local Testing with AgentCore CLI","text":"<pre><code># Configure and test locally\nagentcore configure -e my_async_agent.py\nagentcore launch -l\n\n# Test in another terminal\nagentcore invoke '{\"prompt\": \"start processing\"}' -l\n\n# Check status via ping\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#common-patterns","title":"Common Patterns","text":"<p>Long-Running Processing: <pre><code>@tool\ndef start_data_processing(dataset_size: str = \"medium\") -&gt; str:\n    task_id = app.add_async_task(\"data_processing\", {\"size\": dataset_size})\n\n    def process_data():\n        time.sleep(1800)  # Simulate processing\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=process_data, daemon=True).start()\n    return f\"\ud83d\ude80 Processing started (Task {task_id}). I'll continue in the background!\"\n</code></pre></p> <p>Progress Monitoring: <pre><code>def save_progress(task_id: int, progress: dict):\n    with open(f\"task_progress_{task_id}.json\", 'w') as f:\n        json.dump(progress, f)\n\n@tool\ndef get_progress(task_id: int = None) -&gt; str:\n    # Find and read progress file\n    # Return formatted status\n    pass\n</code></pre></p>"},{"location":"user-guide/runtime/notebook.html","title":"Jupyter Notebook Support","text":"<p>Local Testing Only</p> <p>The notebook interface is intended for local development and testing only. It has rough edges and is not recommended for production use. For production deployment, use the Boto3 SDK instead.</p> <p>The AgentCore Runtime provides basic Jupyter notebook support for quick experimentation and testing.</p>"},{"location":"user-guide/runtime/notebook.html#basic-example","title":"Basic Example","text":"<pre><code># Import the notebook Runtime class\nfrom bedrock_agentcore_starter_toolkit.notebook import Runtime\n\n# Initialize\nruntime = Runtime()\n\n# Configure your agent\nconfig = runtime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyExecutionRole\"\n)\n\n# Test locally\nlocal_result = runtime.launch(local=True)\nprint(f\"Local container: {local_result.tag}\")\n\n# Test your agent\nresponse = runtime.invoke({\"prompt\": \"Hello from notebook!\"})\nprint(response)\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#simple-agent-example","title":"Simple Agent Example","text":"<p>Create a simple agent file first:</p> <pre><code># my_agent.py\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(payload):\n    prompt = payload.get(\"prompt\", \"Hello\")\n    return {\"result\": f\"You said: {prompt}\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Then use it in your notebook:</p> <pre><code>from bedrock_agentcore_starter_toolkit.notebook import Runtime\n\nruntime = Runtime()\n\n# Configure\nruntime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyRole\"\n)\n\n# Launch locally for testing\nruntime.launch(local=True)\n\n# Test the agent\nresponse = runtime.invoke({\"prompt\": \"Test from notebook\"})\nprint(response)  # {\"result\": \"You said: Test from notebook\"}\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#available-methods","title":"Available Methods","text":"<ul> <li><code>configure()</code> - Set up agent configuration</li> <li><code>launch(local=True)</code> - Build and run locally</li> <li><code>invoke(payload)</code> - Test your agent</li> <li><code>status()</code> - Check agent status</li> </ul>"},{"location":"user-guide/runtime/notebook.html#limitations","title":"Limitations","text":"<ul> <li>Local testing focus - Not optimized for production workflows</li> <li>Basic error handling - Limited error reporting compared to CLI</li> <li>Configuration limitations - Fewer options than full CLI interface</li> <li>No interactive prompts - All configuration must be provided programmatically</li> </ul> <p>For full-featured development and production deployment, use the AgentCore CLI instead.</p>"},{"location":"user-guide/runtime/overview.html","title":"AgentCore Runtime SDK Overview","text":"<p>The Amazon Bedrock AgentCore Runtime SDK transforms your Python functions into production-ready AI agents that can be deployed, scaled, and managed in the cloud. At its core, the SDK provides <code>BedrockAgentCoreApp</code> - a powerful HTTP service wrapper that handles all the complexity of agent deployment while letting you focus on your agent's logic.</p>"},{"location":"user-guide/runtime/overview.html#what-is-the-agentcore-runtime-sdk","title":"What is the AgentCore Runtime SDK?","text":"<p>The Runtime SDK is a comprehensive Python framework that bridges the gap between your AI agent code and Amazon Bedrock AgentCore's managed infrastructure. It provides HTTP service wrapper, decorator-based programming, session management, authentication integration, streaming support, async task management, and complete local development tools.</p>"},{"location":"user-guide/runtime/overview.html#core-sdk-components","title":"Core SDK Components","text":""},{"location":"user-guide/runtime/overview.html#bedrockagentcoreapp-the-foundation","title":"BedrockAgentCoreApp: The Foundation","text":"<p><code>BedrockAgentCoreApp</code> extends Starlette to provide an agent-optimized web server with built-in endpoints:</p> <ul> <li><code>/invocations</code> - Main endpoint for processing agent requests</li> <li><code>/ping</code> - Health check endpoint with status reporting</li> <li>Built-in logging - Request tracking with correlation IDs</li> <li>Error handling - Automatic error formatting and status codes</li> <li>Concurrency control - Request limiting and thread pool management</li> </ul> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize with optional debug mode\napp = BedrockAgentCoreApp(debug=True)\n</code></pre>"},{"location":"user-guide/runtime/overview.html#core-decorators","title":"Core Decorators","text":"<p>The SDK uses a decorator-based approach that makes agent development intuitive:</p>"},{"location":"user-guide/runtime/overview.html#appentrypoint-main-agent-function","title":"@app.entrypoint - Main Agent Function","text":"<p>The fundamental decorator that registers your primary agent logic:</p> <pre><code>@app.entrypoint\ndef invoke(payload):\n    \"\"\"Process requests synchronously\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello\")\n    # Your agent logic here\n    return {\"result\": \"Response\"}\n\n# Async version for streaming\n@app.entrypoint\nasync def invoke_async(payload):\n    \"\"\"Process requests asynchronously with streaming\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello\")\n    # Can yield for streaming responses\n    yield {\"chunk\": \"Partial response\"}\n</code></pre>"},{"location":"user-guide/runtime/overview.html#appping-custom-health-checks","title":"@app.ping - Custom Health Checks","text":"<p>Override default health status logic:</p> <pre><code>from bedrock_agentcore.runtime.models import PingStatus\n\n@app.ping\ndef custom_health():\n    \"\"\"Custom health logic\"\"\"\n    if system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n</code></pre>"},{"location":"user-guide/runtime/overview.html#appasync_task-background-processing","title":"@app.async_task - Background Processing","text":"<p>Automatically track long-running operations:</p> <pre><code>@app.async_task\nasync def background_processing():\n    \"\"\"Automatically tracked async task\"\"\"\n    await asyncio.sleep(30)  # Status becomes HEALTHY_BUSY\n    return \"completed\"       # Status returns to HEALTHY\n</code></pre>"},{"location":"user-guide/runtime/overview.html#agent-development-patterns","title":"Agent Development Patterns","text":""},{"location":"user-guide/runtime/overview.html#synchronous-agents","title":"Synchronous Agents","text":"<p>Perfect for quick, deterministic responses:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef simple_agent(payload):\n    \"\"\"Basic request-response agent\"\"\"\n    prompt = payload.get(\"prompt\", \"\")\n\n    # Simple processing logic\n    if \"weather\" in prompt.lower():\n        return {\"result\": \"It's sunny today!\"}\n\n    return {\"result\": f\"You said: {prompt}\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/runtime/overview.html#streaming-agents","title":"Streaming Agents","text":"<p>For real-time, dynamic responses that build over time:</p> <pre><code>from strands import Agent\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\nasync def streaming_agent(payload):\n    \"\"\"Streaming agent with real-time responses\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello\")\n\n    # Stream responses as they're generated\n    stream = agent.stream_async(user_message)\n    async for event in stream:\n        if \"data\" in event:\n            yield event[\"data\"]          # Stream data chunks\n        elif \"message\" in event:\n            yield event[\"message\"]       # Stream message parts\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Key Streaming Features: - Server-Sent Events (SSE): Automatic SSE formatting for web clients - Error Handling: Graceful error streaming with error events - Generator Support: Both sync and async generators supported - Real-time Processing: Immediate response chunks as they're available</p>"},{"location":"user-guide/runtime/overview.html#framework-integration","title":"Framework Integration","text":"<p>The SDK works seamlessly with popular AI frameworks:</p> <p>Strands Integration: <pre><code>from strands import Agent, tool\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\nagent = Agent(tools=[your_tools])\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef strands_agent(payload):\n    \"\"\"Strands-powered agent\"\"\"\n    result = agent(payload.get(\"prompt\"))\n    return {\"result\": result.message}\n</code></pre></p> <p>Custom Framework Integration: <pre><code>@app.entrypoint\nasync def custom_framework_agent(payload):\n    \"\"\"Works with any async framework\"\"\"\n    response = await your_framework.process(payload)\n\n    # Can yield for streaming\n    for chunk in response.stream():\n        yield {\"chunk\": chunk}\n</code></pre></p>"},{"location":"user-guide/runtime/overview.html#session-management","title":"Session Management","text":"<p>The SDK provides built-in session handling for stateful conversations with automatic session creation and management, 15-minute timeout, cross-invocation context persistence, and complete session isolation for security:</p> <pre><code>from bedrock_agentcore.runtime.context import RequestContext\n\n@app.entrypoint\ndef session_aware_agent(payload, context: RequestContext):\n    \"\"\"Agent with session awareness\"\"\"\n    session_id = context.session_id\n    user_message = payload.get(\"prompt\")\n\n    # Your session-aware logic here\n    return {\n        \"result\": f\"Session {session_id}: {user_message}\",\n        \"session_id\": session_id\n    }\n</code></pre> <pre><code># Using AgentCore CLI with session management\nagentcore invoke '{\"prompt\": \"Hello, remember this conversation\"}' --session-id \"conversation-123\"\nagentcore invoke '{\"prompt\": \"What did I say earlier?\"}' --session-id \"conversation-123\"\n</code></pre>"},{"location":"user-guide/runtime/overview.html#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>The SDK integrates with AgentCore's identity services providing automatic AWS credential validation (IAM SigV4) by default or JWT Bearer tokens for OAuth-compatible authentication:</p> <pre><code># Configure JWT authorization using AgentCore CLI\nagentcore configure --entrypoint my_agent.py \\\n  --authorizer-config '{\"customJWTAuthorizer\": {\"discoveryUrl\": \"https://cognito-idp.region.amazonaws.com/pool/.well-known/openid-configuration\", \"allowedClients\": [\"your-client-id\"]}}'\n</code></pre>"},{"location":"user-guide/runtime/overview.html#asynchronous-processing","title":"Asynchronous Processing","text":"<p>For long-running operations, the SDK provides comprehensive async support with automatic task tracking that transitions agent status to HEALTHY_BUSY during processing, or fine-grained manual control:</p> <pre><code># Automatic task tracking\n@app.async_task\nasync def long_running_task():\n    \"\"\"Automatically tracked - agent status becomes BUSY\"\"\"\n    await process_large_dataset()\n    return \"completed\"\n\n@app.entrypoint\nasync def start_processing(payload):\n    \"\"\"Start background task\"\"\"\n    asyncio.create_task(long_running_task())\n    return {\"status\": \"Processing started in background\"}\n\n# Manual task management\n@app.entrypoint\ndef manual_task_control(payload):\n    \"\"\"Manual async task management\"\"\"\n    task_id = app.add_async_task(\"data_processing\", {\"batch_size\": 1000})\n\n    def background_work():\n        time.sleep(60)\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return {\"task_id\": task_id, \"status\": \"started\"}\n</code></pre>"},{"location":"user-guide/runtime/overview.html#local-development","title":"Local Development","text":"<p>The SDK provides a complete local development environment with debug mode for additional capabilities and comprehensive logging with automatic request correlation:</p> <pre><code># Development server with debug mode\napp = BedrockAgentCoreApp(debug=True)\n\nif __name__ == \"__main__\":\n    app.run()  # Default port 8080, auto-detects Docker vs local\n\n# Custom logging\nimport logging\nlogger = logging.getLogger(\"my_agent\")\n\n@app.entrypoint\ndef my_agent(payload):\n    logger.info(\"Processing request: %s\", payload)\n    # Your logic here\n</code></pre> <pre><code># Configure and test locally using AgentCore CLI\nagentcore configure --entrypoint my_agent.py --name my-agent\nagentcore launch --local\nagentcore invoke '{\"prompt\": \"Hello world\"}'\nagentcore invoke '{\"prompt\": \"Remember this\"}' --session-id \"test-session\"\nagentcore invoke '{\"prompt\": \"Hello\"}' --bearer-token \"your-jwt-token\"\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html","title":"QuickStart: Your First Agent in 5 Minutes! \ud83d\ude80","text":"<p>Let's get your first AI agent running on Amazon Bedrock AgentCore in just a few minutes!</p>"},{"location":"user-guide/runtime/quickstart.html#what-you-need","title":"What You Need","text":"<ul> <li>An AWS account</li> <li>Python 3.10+ installed</li> <li>5 minutes of your time \u23f0</li> </ul>"},{"location":"user-guide/runtime/quickstart.html#step-1-install-the-sdk","title":"Step 1: Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#step-2-create-your-agent","title":"Step 2: Create Your Agent","text":"<p>First, install the Strands framework:</p> <pre><code>pip install strands-agents\n</code></pre> <p>Create a file called <code>my_agent.py</code> and add this code:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\ndef invoke(payload):\n    \"\"\"Your AI agent function\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello! How can I help you today?\")\n\n    # Let Strands AI handle the response\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#step-3-test-it-locally","title":"Step 3: Test It Locally","text":"<pre><code># Start your agent\npython my_agent.py\n\n# In another terminal, test it:\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Hello!\"}'\n</code></pre> <p>You should see something like: <code>{\"result\": \"Hello! I'm here to help you with any questions or tasks you have. What would you like to know or do today?\"}</code></p> <p>\ud83c\udf89 Congratulations! Your AI agent is working locally!</p> <p>Note: To run this example hello world agent you will need to set up credentials for our model provider and enable model access. The default model provider for Strands Agents SDK is Amazon Bedrock and the default model is Claude 3.7 Sonnet in the US Oregon (us-west-2) region.</p> <p>For the default Amazon Bedrock model provider, see the Boto3 documentation for setting up AWS credentials. Typically for development, AWS credentials are defined in <code>AWS_</code> prefixed environment variables or configured with <code>aws configure</code>. You will also need to enable Claude 3.7 model access in Amazon Bedrock, following the AWS documentation to enable access.</p>"},{"location":"user-guide/runtime/quickstart.html#step-4-deploy-to-aws","title":"Step 4: Deploy to AWS","text":"<p>Ready to deploy to the cloud? First, install the starter toolkit and set up your project:</p> <pre><code># Install the starter toolkit\npip install bedrock-agentcore-starter-toolkit\n\n# Create requirements.txt\necho \"bedrock-agentcore\nstrands-agents\" &gt; requirements.txt\n\n# Configure your agent\nagentcore configure -e my_agent.py -er &lt;AGENT_IAM_EXECUTION_ROLE&gt;\n\n# Test locally with the toolkit\nagentcore launch -l\n\n# In another terminal, test it:\nagentcore invoke '{\"prompt\": \"Hello!\"}' -l\n\n# Deploy to AWS\nagentcore launch\n\n# Test your deployed agent\nagentcore invoke '{\"prompt\": \"tell me a joke\"}'\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#what-just-happened","title":"\ud83c\udfaf What Just Happened?","text":"<ol> <li>BedrockAgentCoreApp - This wraps your function into an HTTP service</li> <li>@app.entrypoint - This decorator tells AgentCore \"this is my main function\"</li> <li>Local Testing - Your agent runs on <code>http://localhost:8080</code></li> <li>Cloud Deploy - The toolkit packages everything and deploys to AWS</li> </ol>"},{"location":"user-guide/runtime/quickstart.html#quick-troubleshooting","title":"\ud83c\udd98 Quick Troubleshooting","text":"<p>Port 8080 already in use? - Stop other services or use a different port</p> <p>\"Docker not found\" error? - Install Docker Desktop for deployment</p> <p>Permission errors? - Make sure your AWS credentials are configured: <code>aws configure</code></p>"},{"location":"user-guide/runtime/quickstart.html#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Ready to build something amazing? Check out:</p> <ul> <li>Runtime Overview - Deep dive into AgentCore features</li> <li>Memory Guide - Add persistent memory</li> <li>Gateway Tools - Connect external APIs</li> <li>Examples - More complete examples</li> </ul>"}]}